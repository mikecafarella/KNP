{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Knowledge Network Programming System The Knowledge Network Programming System , or KNPS , is a programming system for building knowledge-powered applications. It allows users to more easily use existing knowledge and to curate new knowledge. It has two main components: The Knowledge Client allows users to easily specify a desired relational table, suitable for immediate application use. Specifying almost any desired table can be done in just a few lines of simple code. This table is automatically populated from a comprehensive back-end knowledge graph that includes raw data and data-processing functions on a vast range of topics. In most cases, the user can avoid the typical tedious process of data discovery, marshalling, cleaning, and curation. The Universal Knowledge Collaboration Network is the back-end knowledge graph that powers the Knowledge Client . In many ways it is similar to existing knowledge graphs like Wikidata and others: it hosts data, contains entities and properties, offers a variety of query interfaces, can host both well-known objects and unpopular objects, and relies on social processes for scalable curation. The UKCN is distinctive in that it contains a much wider array of datatypes than is typical: in addition to concrete entities, it can contain files, databases, schemas, properties, execution events, functions, and other items. As a result, the contents of the UKCN can model both the \"real\" world as well as the computational one.","title":"Welcome"},{"location":"#the-knowledge-network-programming-system","text":"The Knowledge Network Programming System , or KNPS , is a programming system for building knowledge-powered applications. It allows users to more easily use existing knowledge and to curate new knowledge. It has two main components: The Knowledge Client allows users to easily specify a desired relational table, suitable for immediate application use. Specifying almost any desired table can be done in just a few lines of simple code. This table is automatically populated from a comprehensive back-end knowledge graph that includes raw data and data-processing functions on a vast range of topics. In most cases, the user can avoid the typical tedious process of data discovery, marshalling, cleaning, and curation. The Universal Knowledge Collaboration Network is the back-end knowledge graph that powers the Knowledge Client . In many ways it is similar to existing knowledge graphs like Wikidata and others: it hosts data, contains entities and properties, offers a variety of query interfaces, can host both well-known objects and unpopular objects, and relies on social processes for scalable curation. The UKCN is distinctive in that it contains a much wider array of datatypes than is typical: in addition to concrete entities, it can contain files, databases, schemas, properties, execution events, functions, and other items. As a result, the contents of the UKCN can model both the \"real\" world as well as the computational one.","title":"The Knowledge Network Programming System"},{"location":"about/","text":"About the project! The Knowledge Network Programming System aims to make knowledge networks (graphs) easier to use and easier to build. We're grateful to the NSF Convergence Accelerator program and to Apple, Inc for funding the project.","title":"About"},{"location":"about/#about-the-project","text":"The Knowledge Network Programming System aims to make knowledge networks (graphs) easier to use and easier to build. We're grateful to the NSF Convergence Accelerator program and to Apple, Inc for funding the project.","title":"About the project!"},{"location":"api/","text":"API Documentation KGPLValue class knps.kgpl. KGPLValue ( val , comment , user='anonymous' , dependency=[] , vid=None , verbose=False ) KGPLValue object. Example: val = KGPLValue('http://example.com') val.do_something() Parameters val Number of seconds to wait between searches comment Paths to ignore user User dependency THe Dependency vid What's a vid? verbose Be verbose about it. getVid ( self ) Return the vid getConcreteVal ( self ) Return the concrete value create_label ( self , label , comment ) Create a label for this KGPLValue Parameters label A label identifier for the value comment Descriptive comment for the value update_label ( self , label , new_comment ) Update the label for this KGPLValue Parameters label A new label identifier for the value comment A new comment KGPLVariable class knps.kgpl. KGPLVariable ( val_id , comment , vid , user='anonymous' , timestamp=None ) KGPLVariable object. Example:: # REPLACE THIS WITH REAL STUFF val = KGPLVariable('http://example.com') val.do_something() Parameters val_id Value ID comment User-readable comment about the variable vid What's a vid? user User timestamp Timestamp of the variable creation getVid ( self ) getValid ( self ) refresh ( self ) getConcreteVal ( self ) API Methods knps. kgpl create_value ( val , comment , user='anonymous' , dependency=[] , verbose=False ) value ( val , comment , user='anonymous' , dependency=[] , verbose=False ) variable ( var_id , val_id , comment , user='anonymous' ) load_val ( vid ) load_var ( vid ) set_var ( kg_var , val_id , new_comment ) Update a KGPLVariable and return it. Parameters kg_var KGPLVariable to be updated val_id ID of the KGPLValue the KGPLVariable should now point to new_comment Descriptive comment for the value get_history ( kg_var ) changeNamespace ( new_url ) viewNamespace ( ) get_var_content ( label )","title":"API Documentation"},{"location":"api/#api-documentation","text":"","title":"API Documentation"},{"location":"api/#kgplvalue","text":"class knps.kgpl. KGPLValue ( val , comment , user='anonymous' , dependency=[] , vid=None , verbose=False ) KGPLValue object. Example: val = KGPLValue('http://example.com') val.do_something()","title":"KGPLValue"},{"location":"api/#kgplvariable","text":"class knps.kgpl. KGPLVariable ( val_id , comment , vid , user='anonymous' , timestamp=None ) KGPLVariable object. Example:: # REPLACE THIS WITH REAL STUFF val = KGPLVariable('http://example.com') val.do_something()","title":"KGPLVariable"},{"location":"api/#api-methods","text":"knps. kgpl create_value ( val , comment , user='anonymous' , dependency=[] , verbose=False ) value ( val , comment , user='anonymous' , dependency=[] , verbose=False ) variable ( var_id , val_id , comment , user='anonymous' ) load_val ( vid ) load_var ( vid ) set_var ( kg_var , val_id , new_comment ) Update a KGPLVariable and return it.","title":"API Methods"},{"location":"install/","text":"Installation Here's how you install and run the Knowledge Client and the Universal Knowledge Collaboration Network . INSTALL DETAILS HERE Tutorial Now that you've installed the system, try out the tutorial .","title":"Installation"},{"location":"install/#installation","text":"Here's how you install and run the Knowledge Client and the Universal Knowledge Collaboration Network . INSTALL DETAILS HERE","title":"Installation"},{"location":"install/#tutorial","text":"Now that you've installed the system, try out the tutorial .","title":"Tutorial"},{"location":"knowledgeclient/","text":"The Knowledge Client This document describes the Knowledge Client , and how to use it to build data-powered applications very quickly. The main goal of the Knowledge Client is to allow users to quickly obtain a high-quality relation, on any topic. It is intended for integration into applications or data science workflows. The client obtains its data from the backing Universal Knowledge Collaboration Network . Users may have to consult the UKCN in order to find the right identifiers for data objects and properties. The current client is written in Python, though there is nothing Python-specific about it: future clients could be written to integrate with programs in Go, Rust, Swift, etc. Data Model A relation in both the Knowledge Client and the UKCN is akin to a traditional RDBMS relation: it's got rows and columns. However, our relations differ in two important ways: 1. Each row has a globally-unique identifier. This is roughly similar to the rowid that some database systems provide. However, our row ids are globally-unique identifiers. 2. Like a traditional RDBMS, each column has a human-understandable name (e.g., \"Salary\") and a type (e.g., \"float\"). In addition, in our system each column has a semantic label . These labels are drawn from a dictionary maintained by the UKCN . For example, a column might be annotated by a label /properties/wikidata/P3618 , which indicates \"base salary\". Execution Model The client allows the programmer to build a single relation at a time. The sequence of steps that the Knowledge Client performs can be thought of as a single \"table initialization step\", followed by a series of joins that grow the table's rows and columns. Some common kinds of initialization include: - Creating a table of a single row and a single column. For example, consider a single column that identifies a KG object, with a single row that represents the Barack Obama object. - Creating a table of many rows and a single column. For example, consider a single column that identifies a KG object, with multiple rows that represent members of a class, such as all instances of the City object. - Creating a table that corresponds to a pre-made table in the UKCN . For example, the programmer may grab a table of dollar-to-Euro exchange statistics. After initialization, the user performs a series of joins that potentially add rows and columns to the table. With some naming guidance from the user, the system synthesizes all of the appropriate column metadata for each new row and column. The system does not try to extract or clean UKCN data at the time of use, apart from a few important exceptions. At the individual fact level, everything the user sees inside a relation created by the Knowledge Client can be found in the UKCN . The exceptions surround cases when the system believes that facts in the UKCN are correct at the individual level, but will yield a relation that is internally inconsistent. Unfortunately, this is a well-known problem in knowledge graphs. Consider the example that Tim Berners-Lee is an example of Computer Scientist , while Computer Scientist is an example of profession . A Knowledge Client user trying to create a table of professions might inadvertently obtain one that includes Tim Berners-Lee . When appropriate, the Knowledge Client will either silently fix these issues, or will issue a warning to the user. Examples Let's try to show a few examples of using the Knowledge Client . INSERT PREEXISTING JUPYTER NOTEBOOK WALKTHROUGH TEXT HERE. ALSO: WE NEED TO FIGURE OUT THE DATA MODEL DISTINCTION BETWEEN USING WIKIDATA VS USING THE SHARING SERVICE. RIGHT NOW THE CLIENT ONLY EXPLOITS WIKIDATA, BUT THIS SHOULD CHANGE VERY SOON.","title":"Knowledge Client"},{"location":"knowledgeclient/#the-knowledge-client","text":"This document describes the Knowledge Client , and how to use it to build data-powered applications very quickly. The main goal of the Knowledge Client is to allow users to quickly obtain a high-quality relation, on any topic. It is intended for integration into applications or data science workflows. The client obtains its data from the backing Universal Knowledge Collaboration Network . Users may have to consult the UKCN in order to find the right identifiers for data objects and properties. The current client is written in Python, though there is nothing Python-specific about it: future clients could be written to integrate with programs in Go, Rust, Swift, etc.","title":"The Knowledge Client"},{"location":"knowledgeclient/#data-model","text":"A relation in both the Knowledge Client and the UKCN is akin to a traditional RDBMS relation: it's got rows and columns. However, our relations differ in two important ways: 1. Each row has a globally-unique identifier. This is roughly similar to the rowid that some database systems provide. However, our row ids are globally-unique identifiers. 2. Like a traditional RDBMS, each column has a human-understandable name (e.g., \"Salary\") and a type (e.g., \"float\"). In addition, in our system each column has a semantic label . These labels are drawn from a dictionary maintained by the UKCN . For example, a column might be annotated by a label /properties/wikidata/P3618 , which indicates \"base salary\".","title":"Data Model"},{"location":"knowledgeclient/#execution-model","text":"The client allows the programmer to build a single relation at a time. The sequence of steps that the Knowledge Client performs can be thought of as a single \"table initialization step\", followed by a series of joins that grow the table's rows and columns. Some common kinds of initialization include: - Creating a table of a single row and a single column. For example, consider a single column that identifies a KG object, with a single row that represents the Barack Obama object. - Creating a table of many rows and a single column. For example, consider a single column that identifies a KG object, with multiple rows that represent members of a class, such as all instances of the City object. - Creating a table that corresponds to a pre-made table in the UKCN . For example, the programmer may grab a table of dollar-to-Euro exchange statistics. After initialization, the user performs a series of joins that potentially add rows and columns to the table. With some naming guidance from the user, the system synthesizes all of the appropriate column metadata for each new row and column. The system does not try to extract or clean UKCN data at the time of use, apart from a few important exceptions. At the individual fact level, everything the user sees inside a relation created by the Knowledge Client can be found in the UKCN . The exceptions surround cases when the system believes that facts in the UKCN are correct at the individual level, but will yield a relation that is internally inconsistent. Unfortunately, this is a well-known problem in knowledge graphs. Consider the example that Tim Berners-Lee is an example of Computer Scientist , while Computer Scientist is an example of profession . A Knowledge Client user trying to create a table of professions might inadvertently obtain one that includes Tim Berners-Lee . When appropriate, the Knowledge Client will either silently fix these issues, or will issue a warning to the user.","title":"Execution Model"},{"location":"knowledgeclient/#examples","text":"Let's try to show a few examples of using the Knowledge Client .","title":"Examples"},{"location":"knowledgeclient/#insert-preexisting-jupyter-notebook-walkthrough-text-here","text":"","title":"INSERT PREEXISTING JUPYTER NOTEBOOK WALKTHROUGH TEXT HERE."},{"location":"knowledgeclient/#also-we-need-to-figure-out-the-data-model-distinction-between-using-wikidata-vs-using-the-sharing-service-right-now-the-client-only-exploits-wikidata-but-this-should-change-very-soon","text":"","title":"ALSO: WE NEED TO FIGURE OUT THE DATA MODEL DISTINCTION BETWEEN USING WIKIDATA VS USING THE SHARING SERVICE.  RIGHT NOW THE CLIENT ONLY EXPLOITS WIKIDATA, BUT THIS SHOULD CHANGE VERY SOON."},{"location":"lineage/","text":"Lineage A value's lineage is a directed tree that describes how the value was computed. A value node is annotated with its id or its url . Functions in KGPL always generate a special value of type Execution . This value contains a special field that identifies the source-function that generated it, along with an optional log message generated during execution. Values with a url can always have their details looked up at a KGPL sharing service . As a result, the lineage tree does not have to be fully-materialized; nodes with a url field just can be referred to and do not need to store further back history. This allows lineage trees, which might be quite large, to be made more compact. There is a single internet-wide KGPL service that will exist as soon as the language starts running.","title":"Lineage"},{"location":"lineage/#lineage","text":"A value's lineage is a directed tree that describes how the value was computed. A value node is annotated with its id or its url . Functions in KGPL always generate a special value of type Execution . This value contains a special field that identifies the source-function that generated it, along with an optional log message generated during execution. Values with a url can always have their details looked up at a KGPL sharing service . As a result, the lineage tree does not have to be fully-materialized; nodes with a url field just can be referred to and do not need to store further back history. This allows lineage trees, which might be quite large, to be made more compact. There is a single internet-wide KGPL service that will exist as soon as the language starts running.","title":"Lineage"},{"location":"restapi/","text":"REST API The UKCN offers a REST API for integration with existing data pipelines. This lets users and organizations who have data product jobs: - Obtain source data for data pipeline inputs - Upload new data pipeline outputs - Upload metadata about the pipeline execution itself Show examples of locally-running data production code. How you grab data, how you make new data, and how you upload metadata to the service. Try using the code that is in the COVID example.","title":"REST API"},{"location":"restapi/#rest-api","text":"The UKCN offers a REST API for integration with existing data pipelines. This lets users and organizations who have data product jobs: - Obtain source data for data pipeline inputs - Upload new data pipeline outputs - Upload metadata about the pipeline execution itself","title":"REST API"},{"location":"restapi/#show-examples-of-locally-running-data-production-code-how-you-grab-data-how-you-make-new-data-and-how-you-upload-metadata-to-the-service-try-using-the-code-that-is-in-the-covid-example","text":"","title":"Show examples of locally-running data production code.  How you grab data, how you make new data, and how you upload metadata to the service.  Try using the code that is in the COVID example."},{"location":"sharingservice/","text":"The Univeral Knowledge Collaboration Network The UKCN is a knowledge graph that is similar to other Wikidata-style knowledge graphs. Like existing systems, it: - Hosts data - Contains entities and properties - Offers a range of query interfaces, such as SPARQL and the Knowledge Client - Hosts both well-known objects (e.g., Barack Obama) and obscure ones (e.g., a random uploaded image file) - Largely relies on social processes for data curation Unlike existing systems, the UKCN also models the computational world, with support for storing files, databases, schemas, execution events, functions, and other items. This allows the UKCN to apply the virtues of traditional knowledge graph systems --- topic flexibility and efficient curation --- to all the data that an application developer might need. Using the UKCN Like Wikidata, the UKCN presents an HTML browser interface for users. Anyone can search and retrieve data from the UKCN . With an account, a user can create new UKCN objects, annotate and edit existing ones, run functions, and carry out a range of other tasks. Every data object in the UKCN has its own URL. This URL can be used in the browser to find an object. The same URL can be provided to the Knowledge Client for various use cases. Sharing data with a colleague is as easy as sharing a webpage: just send your friend the appropriate URL. Every data object in the UKCN has an affiliated user account as its owner. In the current version of the UKCN , all data objects are world-readable and world-writable. Future versions will implement user permissions that prevent unauthorized access and edits. Data Model Data objects in UKCN are immutable: with one important exception, they can never change and are never deleted. Every immutable data object has an obscure identifier . This can be used to fetch the data object, forever. Because obscure identifers are never recycled, and because data objects can never be modified, UKCN can be used for long-term provenance tracking. An object with an obscure identifier is akin to a particular version of a particular entity in Wikidata; it might be useful and popular, but probably not. The UKCN also offers well-known identifiers . This is the only kind of value in the UKCN that can change over time. A well-known identifier starts with the letter 'X', followed by an integer. It is akin to the set of top-level entities in Wikidata, such as Q76 (Barack Obama). A well-known identifier always points to a single immutable data object (which, of course, also has an obscure identifier). This is similar to the way in which a high-level Wikidata identifier (e.g, Q76) at any moment in time points to a particular version of the entity. In practice, users can mostly ignore this distinction. Most people will mostly deal with well-known objects; that is, objects currently pointed-to by a well-known identifier . Non-well-known objects are generally only of interest when looking at past versions (e.g., for provenance tracking reasons). Users retrieving UKCN objects using a single query interface, whether its via an obscure identifier or a well-known identifier, Deployment There is a single UKCN that is implemented across multiple servers, in the same way there is a single World Wide Web implemented across multiple web servers. This will allow users and institutions to host data that might be tied to a particular location, while allowing users to ignore physical placement when annotating and curating data. However, the current UKCN software implements only \"single-server mode\". Interfaces The UKCN allows users to access it in three ways: 1. When building applications, via the Knowledge Client 2. When curating and sharing data, via the HTML Browser interface 3. When uploading novel data artifacts programmatically, via the REST API This last interface is primarily useful when integrating the UKCN with existing data pipelines. Getting Started Go here to install and run the UKCN system.","title":"Sharing Service"},{"location":"sharingservice/#the-univeral-knowledge-collaboration-network","text":"The UKCN is a knowledge graph that is similar to other Wikidata-style knowledge graphs. Like existing systems, it: - Hosts data - Contains entities and properties - Offers a range of query interfaces, such as SPARQL and the Knowledge Client - Hosts both well-known objects (e.g., Barack Obama) and obscure ones (e.g., a random uploaded image file) - Largely relies on social processes for data curation Unlike existing systems, the UKCN also models the computational world, with support for storing files, databases, schemas, execution events, functions, and other items. This allows the UKCN to apply the virtues of traditional knowledge graph systems --- topic flexibility and efficient curation --- to all the data that an application developer might need.","title":"The Univeral Knowledge Collaboration Network"},{"location":"sharingservice/#using-the-ukcn","text":"Like Wikidata, the UKCN presents an HTML browser interface for users. Anyone can search and retrieve data from the UKCN . With an account, a user can create new UKCN objects, annotate and edit existing ones, run functions, and carry out a range of other tasks. Every data object in the UKCN has its own URL. This URL can be used in the browser to find an object. The same URL can be provided to the Knowledge Client for various use cases. Sharing data with a colleague is as easy as sharing a webpage: just send your friend the appropriate URL. Every data object in the UKCN has an affiliated user account as its owner. In the current version of the UKCN , all data objects are world-readable and world-writable. Future versions will implement user permissions that prevent unauthorized access and edits.","title":"Using the UKCN"},{"location":"sharingservice/#data-model","text":"Data objects in UKCN are immutable: with one important exception, they can never change and are never deleted. Every immutable data object has an obscure identifier . This can be used to fetch the data object, forever. Because obscure identifers are never recycled, and because data objects can never be modified, UKCN can be used for long-term provenance tracking. An object with an obscure identifier is akin to a particular version of a particular entity in Wikidata; it might be useful and popular, but probably not. The UKCN also offers well-known identifiers . This is the only kind of value in the UKCN that can change over time. A well-known identifier starts with the letter 'X', followed by an integer. It is akin to the set of top-level entities in Wikidata, such as Q76 (Barack Obama). A well-known identifier always points to a single immutable data object (which, of course, also has an obscure identifier). This is similar to the way in which a high-level Wikidata identifier (e.g, Q76) at any moment in time points to a particular version of the entity. In practice, users can mostly ignore this distinction. Most people will mostly deal with well-known objects; that is, objects currently pointed-to by a well-known identifier . Non-well-known objects are generally only of interest when looking at past versions (e.g., for provenance tracking reasons). Users retrieving UKCN objects using a single query interface, whether its via an obscure identifier or a well-known identifier,","title":"Data Model"},{"location":"sharingservice/#deployment","text":"There is a single UKCN that is implemented across multiple servers, in the same way there is a single World Wide Web implemented across multiple web servers. This will allow users and institutions to host data that might be tied to a particular location, while allowing users to ignore physical placement when annotating and curating data. However, the current UKCN software implements only \"single-server mode\".","title":"Deployment"},{"location":"sharingservice/#interfaces","text":"The UKCN allows users to access it in three ways: 1. When building applications, via the Knowledge Client 2. When curating and sharing data, via the HTML Browser interface 3. When uploading novel data artifacts programmatically, via the REST API This last interface is primarily useful when integrating the UKCN with existing data pipelines.","title":"Interfaces"},{"location":"sharingservice/#getting-started","text":"Go here to install and run the UKCN system.","title":"Getting Started"},{"location":"tutorial/","text":"Tutorial and Walkthrough We will walk through an example of adding data to the UKCN and then using it in the Knowledge Client . You should have already installed the software. If not, go follow the installation instructions . INTEGRATED TUTORIAL HERE . LET'S DO THE COVID EXAMPLE, OR THE EU GDP EXAMPLE .","title":"Tutorial and Walkthrough"},{"location":"tutorial/#tutorial-and-walkthrough","text":"We will walk through an example of adding data to the UKCN and then using it in the Knowledge Client . You should have already installed the software. If not, go follow the installation instructions . INTEGRATED TUTORIAL HERE . LET'S DO THE COVID EXAMPLE, OR THE EU GDP EXAMPLE .","title":"Tutorial and Walkthrough"},{"location":"old/docs/","text":"Execution Environments Every invocation of a KGPL function entails a small custom set of KG entities that describe the execution environment . These values can be used by a function to control output depending on the execution environment. For example, the same code might be runnable either on a laptop with a large screen, or in voice mode. If the system returns a table, it might make sense to present the entire result on a scrollable laptop screen, but in a voice setting it would only make sense to read the first tuple aloud. How can this be implemented? RenderTable(t: __Table__): __Table__ { if (__Environment__.isVoiceOnly) { return t[0] } else { return t } } The conditional statement overall always has a precondition probability of 1. One particular branch has a precondition probability that depends on whether its tested condition is true (or, for the else branch, (1-p)). Managing Uncertainty Thresholds In some cases, the precondition probability is useful for comparing different alternatives. The user might have invoked Compare(x, y) ; depending on the values for x and y , either Compare(x: Person, y:Person) or Compare(x: TimeSeries, y: TimeSeries) might be more probable. But what should be done when the precondition probability of the maximally-probable option is still quite low? The right course of action depends on the environment and context. For example, the unambiguous interface probably should always run whatever the user asks for, while the implicit invocation interface should probably only run code when the confidence is above a certain threshold. Each invocation interface can register two special values: the minimum probability for function execution, and the minimum probability for warning the user prior to function execution. Finally, there is the probability associated with conditionals. The True branch is always evaluated when its probability is 95% or higher. Run Once, Debug Everywhere : It is easy to share, examine, discuss, copy, and modify single executions. The Universal Class Library : KGPL offers a class library of more than 70 million individual and easily-understood types. These types reflect real-world categories, such as Presidents, Buildings, Emotions, Satellites, and many more Easy Fine-Grained Code Sharing : KGPL makes it easy to share even individual variables with other programs. Practical Python : Despite all of the above features, KGPL looks and feels like Python 99% of the time","title":"Docs"},{"location":"old/docs/#execution-environments","text":"Every invocation of a KGPL function entails a small custom set of KG entities that describe the execution environment . These values can be used by a function to control output depending on the execution environment. For example, the same code might be runnable either on a laptop with a large screen, or in voice mode. If the system returns a table, it might make sense to present the entire result on a scrollable laptop screen, but in a voice setting it would only make sense to read the first tuple aloud. How can this be implemented? RenderTable(t: __Table__): __Table__ { if (__Environment__.isVoiceOnly) { return t[0] } else { return t } } The conditional statement overall always has a precondition probability of 1. One particular branch has a precondition probability that depends on whether its tested condition is true (or, for the else branch, (1-p)).","title":"Execution Environments"},{"location":"old/docs/#managing-uncertainty-thresholds","text":"In some cases, the precondition probability is useful for comparing different alternatives. The user might have invoked Compare(x, y) ; depending on the values for x and y , either Compare(x: Person, y:Person) or Compare(x: TimeSeries, y: TimeSeries) might be more probable. But what should be done when the precondition probability of the maximally-probable option is still quite low? The right course of action depends on the environment and context. For example, the unambiguous interface probably should always run whatever the user asks for, while the implicit invocation interface should probably only run code when the confidence is above a certain threshold. Each invocation interface can register two special values: the minimum probability for function execution, and the minimum probability for warning the user prior to function execution. Finally, there is the probability associated with conditionals. The True branch is always evaluated when its probability is 95% or higher. Run Once, Debug Everywhere : It is easy to share, examine, discuss, copy, and modify single executions. The Universal Class Library : KGPL offers a class library of more than 70 million individual and easily-understood types. These types reflect real-world categories, such as Presidents, Buildings, Emotions, Satellites, and many more Easy Fine-Grained Code Sharing : KGPL makes it easy to share even individual variables with other programs. Practical Python : Despite all of the above features, KGPL looks and feels like Python 99% of the time","title":"Managing Uncertainty Thresholds"},{"location":"old/tour/","text":"A Tour of KGPL Here is a whirlwind tour of KGPL! Values A value in KGPL contains several subfields. The concrete-value field is the standard value you actually want to process and use. It can be one of: A Python value An Entity . This is a special type designed to model the Wikidata KG entity model. It has properties and values. The property labels may be annotated with a label from a shared namespace. A Relation . This is a data table with a schema of property names. The id field is a universally-unique identifier. It is akin to a UUID or GUID, but since we need one for every value in every execution of a KGPL program, we likely need more bits than previous UUID standards. The lineage field describes how the value was computed. It is a directed graph that describes the unique values and function that were used to compute this value. ( Read more about lineage , if you like.) The url field is populated only after the value is \"registered\" with a KGPL sharing service . The url field, if populated, always syntactically contains the id (so if you have the url , you can derive the id ). When a value is registered with a KGPL sharing service, that service can always return all of the value's fields. The annotations field is arbitrary human-readable information that can be added to the value. It is carried along with the value, but has no practical impact on its usage. A value is created once and can never be edited. As a result, a registered value never needs to be edited. Values can be shared between programs or users via simply sharing the URL. As a result, before a value can be shared it must be registered at a KGPL sharing service. When a value is shared, the URL and its lineage is always available to the consumer. This means every KGPL program output can be examined for how it was computed. This is helpful for sharing datasets in a scientific, engineering, or policy context. You can observe all of the KGPL value fields at the Python REPL: >>> import kgpl >>> from kgpl import kgplSquare >>> kgplSquare ( 3 ) concrete - value : 9 id : 0051051e-6 e0e - 11 ea - b7d5 - 8 c859062bac5 lineage : < kgpl . Lineage object at 0x10cd02470 > url : < unregistered > annotations : [] Variables KGPL variables are named objects that refer to a particular KGPL value at any given point in time. The variable's id field is a universally-unique identifier for all time and space. This never changes. The current-value field is the id of a KGPL value. This can be changed over time The owner field indicates the username of the owner of the variable. This is important for determining who is allowed to modify a variable. The url field is optional. It is populated when the variable is registered with a KGPL sharing service . The URL syntactically contains the variable's id . When a KGPL sharing service is queried using this URL, it will return all of the variable's other fields. Note that in principle, a variable could be shared and widely known, but its value could be more limited. This might be appropriate in certain information-sharing scenarios; for example, the government knows that there is a precomputed monthly unemployment number, but this number is not widely revealed until a particular time and date. The annotations field is arbitrary human-readable information that can be added to the variable. It is carried along with the variable, but has no practical impact on its programmatic KGPL usage. It could have an impact on the findability or usefulness of the variable for other human beings. For example, there might be a search service that allows users to find useful variables on an existing KGPL sharing service. This search service might use the annotations field to get better search results. When a registered variable is changed, the update should be immediately transmitted to its registered sharing service. You can observe all of the KGPL variable fields --- and those of its current value --- at the Python REPL: >>> import kgpl >>> from kgpl import kgplSquare >>> from kgpl import KGPLVariable >>> >>> x = KGPLVariable ( kgplSquare ( 3 )) >>> x id : 8 cf28bb1 - ea67 - 4 c37 - a949 - 7 d8bab2be6f8 owner : michjc url : < unregistered > annotations : [] current - value : 9 >>> >>> x . currentvalue concrete - value : 9 id : 01 f9da67 - 9206 - 499 f - a985 - 30 d734ffbbef lineage : < kgpl . Lineage object at 0x101338588 > url : < unregistered > annotations : [] >>> >>> x . reassign ( kgplSquare ( 4 )) >>> x id : 8 cf28bb1 - ea67 - 4 c37 - a949 - 7 d8bab2be6f8 owner : michjc url : < unregistered > annotations : [] current - value : 16 >>> >>> x . currentvalue concrete - value : 16 id : 2 ac5abea - e790 - 4100 - 828 c - 39 f3637e9bc5 lineage : < kgpl . Lineage object at 0x101417080 > url : < unregistered > annotations : [] Variables are pretty rich objects in KGPL. You can read more about them here . Types KGPL includes a large general-purpose type library. This library has thousands of types and is meant to cover most \"real world\" concepts. KGPL Entity and Relation values may fall into zero or more of these types. The types are meant to describe useful classes of values, such as: Politicians Countries GDPData HeartDiseaseData and many others The exact set of types in the KGPL type library will change over time, but the intention is for it to be general-purpose and comprehensive. The KGPL type namespace is a URI-style manner of naming types. The core types are named as /core/<typelabel> , like /core/Politician , /core/GDPData , and so on. You use a KGPL type in Python code like this: def computeElectoralWinRatio ( p : / core / Politician ): winCount = 0 totalElections = 0 for election , didWin in p . elections : totalElections += 1 if didWin : winCount += 1 return winCount / float ( totalElections ) A type in KGPL is a value that is treated in certain special ways. Its concrete-value field is a tuple of two fields: typename is a URL-style human-understandable label that describes the intended type. typefunc is a function that takes as an argument a single parameter: any KGPL value. It returns a probability that determines whether the given argument is a \"member\" of the type. Users can add new types by creating new (typename, typefunc) pairs and registering them with an accessible KGPL Sharing Service . The desired namespace for user-registered types is not yet entirely clear, but should be something like /users/mcafarella/Recipe or /umich.edu/College or /mit.edu/Lab . In the core library, the intention is for most type-detection functions to be machine-learned artifacts, but there is nothing that requires this. It might especially make sense for users to define types algorithmically. Functions A function is a piece of executable code. A function is another kind of value. Like a value, it can be created, but not edited, destroyed, or versioned. When a function is executed, it yields the standard results (that is values), as well as an Execution value. This value encapsulates the execution event via three fields: The source-function field is the identifier of the value that represents the function that was executed. The timestamp value simply indicates when the function was run. The log value indicates any information emitted by the function during execution. Some of the nodes in a value's directed lineage tree are Execution values. Like other values, a function can be assigned to a variable. This is how a function is named. That variable can change its value over time, like any other variable. It might be shared, become well-known, and so on. A function value is fixed, but most of the time when programming or sharing with others, users refer to a function via a variable name. Since type membership is probabilistic, it is possible that a single function invocation may satisfy multiple functions simultaneously. In these cases, the system will invoke the maximally-probable function. Code The body of a KGPL Function is simply Python code, with a few minor differences: The function signature must declare types for all of its input parameters. These can include KGPL Types. Function inputs are KGPL variables. The function will be executed in a VM-style environment that will be destroyed immediately after execution, so the programmer cannot rely on retaining side effects. All important results must be returned by the function call. The function must create KGPL-style results to be returned. In particular, it must create an Execution value and appropriate KGPL-style values (with unique identifiers and lineage) for all returned items. Building an accurate lineage graph for each output value can be burdensome. If the function's outputs are created using special KGPL helper functions, this output lineage graph will be generated automatically. Sharing KGPL enables easy value sharing and variable sharing . Both require the use of a KGPL sharing service . In order to share a value with another user or program, a KGPL runtime must: Register the value(s) with a KGPL sharing service. The runtime transmits all the relevant data to the service. The service replies with a URL. Retain the URL, which can be forwarded to external users or programs. Be aware that the KGPL sharing service may replicate the value and share with other KGPL services. Registering a variable is much the same, with two important differences: A KGPL sharing service cannot replicate a variable with other services. A registered variable lives on a single service. A KGPL sharing service must enforce variable ownership access control. Only the owner of a variable is allowed to update its value in the future. Interfaces How is a KGPL function started by a user? Several possible interfaces are available. Unambiguous Invocation The most straightforward is the unambiguous interface , intended for data scientists and developers. This is how one KGPL function invokes another. The function name and its parameters are unambiguously indicated by the user's code. The only ambiguity around which method is invoked is driven by identically-named functions with different type signatures. Method-Ambiguous Invocation Slightly more user-friendly is the method-ambiguous interface , in which parameters and their order are indicated entirely unambiguously, but the method name is indicated via text keywords. This might be appropriate in a search-style ranking interface. Implicit Invocation Finally, the most user-friendly input mode is one in which the function, its parameters, and their order are given by the user entirely via a text-style or voice-driven interface. Tools The KGPL system includes several pieces of code and data: The KGPL core type and variable library. These are types and variables that are globally accessible. They are shared at the \"root\" KGPL sharing service. Python libraries that implement the type, variable, and value systems. A sharing service runtime binary that can be downloaded and executed by anyone. A \"root\" sharing service that runs that binary and is always available to all KGPL users.","title":"A Tour of KGPL"},{"location":"old/tour/#a-tour-of-kgpl","text":"Here is a whirlwind tour of KGPL!","title":"A Tour of KGPL"},{"location":"old/tour/#values","text":"A value in KGPL contains several subfields. The concrete-value field is the standard value you actually want to process and use. It can be one of: A Python value An Entity . This is a special type designed to model the Wikidata KG entity model. It has properties and values. The property labels may be annotated with a label from a shared namespace. A Relation . This is a data table with a schema of property names. The id field is a universally-unique identifier. It is akin to a UUID or GUID, but since we need one for every value in every execution of a KGPL program, we likely need more bits than previous UUID standards. The lineage field describes how the value was computed. It is a directed graph that describes the unique values and function that were used to compute this value. ( Read more about lineage , if you like.) The url field is populated only after the value is \"registered\" with a KGPL sharing service . The url field, if populated, always syntactically contains the id (so if you have the url , you can derive the id ). When a value is registered with a KGPL sharing service, that service can always return all of the value's fields. The annotations field is arbitrary human-readable information that can be added to the value. It is carried along with the value, but has no practical impact on its usage. A value is created once and can never be edited. As a result, a registered value never needs to be edited. Values can be shared between programs or users via simply sharing the URL. As a result, before a value can be shared it must be registered at a KGPL sharing service. When a value is shared, the URL and its lineage is always available to the consumer. This means every KGPL program output can be examined for how it was computed. This is helpful for sharing datasets in a scientific, engineering, or policy context. You can observe all of the KGPL value fields at the Python REPL: >>> import kgpl >>> from kgpl import kgplSquare >>> kgplSquare ( 3 ) concrete - value : 9 id : 0051051e-6 e0e - 11 ea - b7d5 - 8 c859062bac5 lineage : < kgpl . Lineage object at 0x10cd02470 > url : < unregistered > annotations : []","title":"Values"},{"location":"old/tour/#variables","text":"KGPL variables are named objects that refer to a particular KGPL value at any given point in time. The variable's id field is a universally-unique identifier for all time and space. This never changes. The current-value field is the id of a KGPL value. This can be changed over time The owner field indicates the username of the owner of the variable. This is important for determining who is allowed to modify a variable. The url field is optional. It is populated when the variable is registered with a KGPL sharing service . The URL syntactically contains the variable's id . When a KGPL sharing service is queried using this URL, it will return all of the variable's other fields. Note that in principle, a variable could be shared and widely known, but its value could be more limited. This might be appropriate in certain information-sharing scenarios; for example, the government knows that there is a precomputed monthly unemployment number, but this number is not widely revealed until a particular time and date. The annotations field is arbitrary human-readable information that can be added to the variable. It is carried along with the variable, but has no practical impact on its programmatic KGPL usage. It could have an impact on the findability or usefulness of the variable for other human beings. For example, there might be a search service that allows users to find useful variables on an existing KGPL sharing service. This search service might use the annotations field to get better search results. When a registered variable is changed, the update should be immediately transmitted to its registered sharing service. You can observe all of the KGPL variable fields --- and those of its current value --- at the Python REPL: >>> import kgpl >>> from kgpl import kgplSquare >>> from kgpl import KGPLVariable >>> >>> x = KGPLVariable ( kgplSquare ( 3 )) >>> x id : 8 cf28bb1 - ea67 - 4 c37 - a949 - 7 d8bab2be6f8 owner : michjc url : < unregistered > annotations : [] current - value : 9 >>> >>> x . currentvalue concrete - value : 9 id : 01 f9da67 - 9206 - 499 f - a985 - 30 d734ffbbef lineage : < kgpl . Lineage object at 0x101338588 > url : < unregistered > annotations : [] >>> >>> x . reassign ( kgplSquare ( 4 )) >>> x id : 8 cf28bb1 - ea67 - 4 c37 - a949 - 7 d8bab2be6f8 owner : michjc url : < unregistered > annotations : [] current - value : 16 >>> >>> x . currentvalue concrete - value : 16 id : 2 ac5abea - e790 - 4100 - 828 c - 39 f3637e9bc5 lineage : < kgpl . Lineage object at 0x101417080 > url : < unregistered > annotations : [] Variables are pretty rich objects in KGPL. You can read more about them here .","title":"Variables"},{"location":"old/tour/#types","text":"KGPL includes a large general-purpose type library. This library has thousands of types and is meant to cover most \"real world\" concepts. KGPL Entity and Relation values may fall into zero or more of these types. The types are meant to describe useful classes of values, such as: Politicians Countries GDPData HeartDiseaseData and many others The exact set of types in the KGPL type library will change over time, but the intention is for it to be general-purpose and comprehensive. The KGPL type namespace is a URI-style manner of naming types. The core types are named as /core/<typelabel> , like /core/Politician , /core/GDPData , and so on. You use a KGPL type in Python code like this: def computeElectoralWinRatio ( p : / core / Politician ): winCount = 0 totalElections = 0 for election , didWin in p . elections : totalElections += 1 if didWin : winCount += 1 return winCount / float ( totalElections ) A type in KGPL is a value that is treated in certain special ways. Its concrete-value field is a tuple of two fields: typename is a URL-style human-understandable label that describes the intended type. typefunc is a function that takes as an argument a single parameter: any KGPL value. It returns a probability that determines whether the given argument is a \"member\" of the type. Users can add new types by creating new (typename, typefunc) pairs and registering them with an accessible KGPL Sharing Service . The desired namespace for user-registered types is not yet entirely clear, but should be something like /users/mcafarella/Recipe or /umich.edu/College or /mit.edu/Lab . In the core library, the intention is for most type-detection functions to be machine-learned artifacts, but there is nothing that requires this. It might especially make sense for users to define types algorithmically.","title":"Types"},{"location":"old/tour/#functions","text":"A function is a piece of executable code. A function is another kind of value. Like a value, it can be created, but not edited, destroyed, or versioned. When a function is executed, it yields the standard results (that is values), as well as an Execution value. This value encapsulates the execution event via three fields: The source-function field is the identifier of the value that represents the function that was executed. The timestamp value simply indicates when the function was run. The log value indicates any information emitted by the function during execution. Some of the nodes in a value's directed lineage tree are Execution values. Like other values, a function can be assigned to a variable. This is how a function is named. That variable can change its value over time, like any other variable. It might be shared, become well-known, and so on. A function value is fixed, but most of the time when programming or sharing with others, users refer to a function via a variable name. Since type membership is probabilistic, it is possible that a single function invocation may satisfy multiple functions simultaneously. In these cases, the system will invoke the maximally-probable function.","title":"Functions"},{"location":"old/tour/#code","text":"The body of a KGPL Function is simply Python code, with a few minor differences: The function signature must declare types for all of its input parameters. These can include KGPL Types. Function inputs are KGPL variables. The function will be executed in a VM-style environment that will be destroyed immediately after execution, so the programmer cannot rely on retaining side effects. All important results must be returned by the function call. The function must create KGPL-style results to be returned. In particular, it must create an Execution value and appropriate KGPL-style values (with unique identifiers and lineage) for all returned items. Building an accurate lineage graph for each output value can be burdensome. If the function's outputs are created using special KGPL helper functions, this output lineage graph will be generated automatically.","title":"Code"},{"location":"old/tour/#sharing","text":"KGPL enables easy value sharing and variable sharing . Both require the use of a KGPL sharing service . In order to share a value with another user or program, a KGPL runtime must: Register the value(s) with a KGPL sharing service. The runtime transmits all the relevant data to the service. The service replies with a URL. Retain the URL, which can be forwarded to external users or programs. Be aware that the KGPL sharing service may replicate the value and share with other KGPL services. Registering a variable is much the same, with two important differences: A KGPL sharing service cannot replicate a variable with other services. A registered variable lives on a single service. A KGPL sharing service must enforce variable ownership access control. Only the owner of a variable is allowed to update its value in the future.","title":"Sharing"},{"location":"old/tour/#interfaces","text":"How is a KGPL function started by a user? Several possible interfaces are available.","title":"Interfaces"},{"location":"old/tour/#unambiguous-invocation","text":"The most straightforward is the unambiguous interface , intended for data scientists and developers. This is how one KGPL function invokes another. The function name and its parameters are unambiguously indicated by the user's code. The only ambiguity around which method is invoked is driven by identically-named functions with different type signatures.","title":"Unambiguous Invocation"},{"location":"old/tour/#method-ambiguous-invocation","text":"Slightly more user-friendly is the method-ambiguous interface , in which parameters and their order are indicated entirely unambiguously, but the method name is indicated via text keywords. This might be appropriate in a search-style ranking interface.","title":"Method-Ambiguous Invocation"},{"location":"old/tour/#implicit-invocation","text":"Finally, the most user-friendly input mode is one in which the function, its parameters, and their order are given by the user entirely via a text-style or voice-driven interface.","title":"Implicit Invocation"},{"location":"old/tour/#tools","text":"The KGPL system includes several pieces of code and data: The KGPL core type and variable library. These are types and variables that are globally accessible. They are shared at the \"root\" KGPL sharing service. Python libraries that implement the type, variable, and value systems. A sharing service runtime binary that can be downloaded and executed by anyone. A \"root\" sharing service that runs that binary and is always available to all KGPL users.","title":"Tools"},{"location":"old/values/","text":"Values","title":"Values"},{"location":"old/values/#values","text":"","title":"Values"},{"location":"old/variables/","text":"Variables KGPL variables are named objects that refer to a particular KGPL value at any given point in time. The variable's id field is a universally-unique identifier for all time and space. This never changes. The current-value field is the id of a KGPL value. This can be changed over time The owner field indicates the username of the owner of the variable. This is important for determining who is allowed to modify a variable. The url field is optional. It is populated when the variable is registered with a KGPL sharing service . The URL syntactically contains the variable's id . When a KGPL sharing service is queried using this URL, it will return all of the variable's other fields. Note that in principle, a variable could be shared and widely known, but its value could be more limited. This might be appropriate in certain information-sharing scenarios; for example, the government knows that there is a precomputed monthly unemployment number, but this number is not widely revealed until a particular time and date. The annotations field is arbitrary human-readable information that can be added to the variable. It is carried along with the variable, but has no practical impact on its programmatic KGPL usage. It could have an impact on the findability or usefulness of the variable for other human beings. For example, there might be a search service that allows users to find useful variables on an existing KGPL sharing service . This search service might use the annotations field to get better search results. When a registered variable is changed, the update should be immediately transmitted to its registered sharing service. You can observe all of the KGPL variable fields --- and those of its current value --- at the Python REPL: >>> import kgpl >>> from kgpl import kgplSquare >>> from kgpl import KGPLVariable >>> >>> x = KGPLVariable ( kgplSquare ( 3 )) >>> x id : 8 cf28bb1 - ea67 - 4 c37 - a949 - 7 d8bab2be6f8 owner : michjc url : < unregistered > annotations : [] current - value : 9 >>> >>> x . currentvalue concrete - value : 9 id : 01 f9da67 - 9206 - 499 f - a985 - 30 d734ffbbef lineage : < kgpl . Lineage object at 0x101338588 > url : < unregistered > annotations : [] >>> >>> x . reassign ( kgplSquare ( 4 )) >>> x id : 8 cf28bb1 - ea67 - 4 c37 - a949 - 7 d8bab2be6f8 owner : michjc url : < unregistered > annotations : [] current - value : 16 >>> >>> x . currentvalue concrete - value : 16 id : 2 ac5abea - e790 - 4100 - 828 c - 39 f3637e9bc5 lineage : < kgpl . Lineage object at 0x101417080 > url : < unregistered > annotations : [] Relationship to Knowledge Graph Entities An object in an extant knowledge graph, such as Wikidata, can be viewed as a registered KGPL variable. For example, the Barack Obama URL at Wikidata (Q76) is a uniquely-identified variable that refers at any point in time to a particular value. That value has the Entity type. Most KGPL variables will never be registered. Most registered ones will never become well-known. But a small fraction will become well-known and potentially used by many. The current KGs can be thought of as sets of registered and well-known KGPL variables. Updates A KGPL variable can be updated whenever its owner decides it is appropriate. Some KGPL variables will be updated by social mechanisms -- basically, whenever a human wants to, the variable gets updated. Some will be updated according to a regular schedule, such as a variable that reflects a stock price, which gets updated every minute. Some will be updated according to external events, such as a temperature sensor reading. This update policy should be described in the human-readable part of a well-known variable. A KGPL variable can be updated by a process that is external to the KGPL universe. That is, external actors (social software, data feeds, etc) can publish variables \"into\" the KGPL variable space. But much of the time, a KGPL variable is updated because a KGPL program runs and changes the value. That's great! KGPL programs can register interest in their upstream variables. When the upstream variable is modified, the KGPL program may decide to re-execute. Permissions KGPL variables are owned by a single user and registered at a single service. Unlike values, variables have a \"home service\". That service might be an internet-wide one, or limited to a particular group. Unlike value sharing, sharing a previously-private variable with an external party can only be done via changing access control to the home sharing service. Variables cannot be transmitted between sharing services.","title":"Variables"},{"location":"old/variables/#variables","text":"KGPL variables are named objects that refer to a particular KGPL value at any given point in time. The variable's id field is a universally-unique identifier for all time and space. This never changes. The current-value field is the id of a KGPL value. This can be changed over time The owner field indicates the username of the owner of the variable. This is important for determining who is allowed to modify a variable. The url field is optional. It is populated when the variable is registered with a KGPL sharing service . The URL syntactically contains the variable's id . When a KGPL sharing service is queried using this URL, it will return all of the variable's other fields. Note that in principle, a variable could be shared and widely known, but its value could be more limited. This might be appropriate in certain information-sharing scenarios; for example, the government knows that there is a precomputed monthly unemployment number, but this number is not widely revealed until a particular time and date. The annotations field is arbitrary human-readable information that can be added to the variable. It is carried along with the variable, but has no practical impact on its programmatic KGPL usage. It could have an impact on the findability or usefulness of the variable for other human beings. For example, there might be a search service that allows users to find useful variables on an existing KGPL sharing service . This search service might use the annotations field to get better search results. When a registered variable is changed, the update should be immediately transmitted to its registered sharing service. You can observe all of the KGPL variable fields --- and those of its current value --- at the Python REPL: >>> import kgpl >>> from kgpl import kgplSquare >>> from kgpl import KGPLVariable >>> >>> x = KGPLVariable ( kgplSquare ( 3 )) >>> x id : 8 cf28bb1 - ea67 - 4 c37 - a949 - 7 d8bab2be6f8 owner : michjc url : < unregistered > annotations : [] current - value : 9 >>> >>> x . currentvalue concrete - value : 9 id : 01 f9da67 - 9206 - 499 f - a985 - 30 d734ffbbef lineage : < kgpl . Lineage object at 0x101338588 > url : < unregistered > annotations : [] >>> >>> x . reassign ( kgplSquare ( 4 )) >>> x id : 8 cf28bb1 - ea67 - 4 c37 - a949 - 7 d8bab2be6f8 owner : michjc url : < unregistered > annotations : [] current - value : 16 >>> >>> x . currentvalue concrete - value : 16 id : 2 ac5abea - e790 - 4100 - 828 c - 39 f3637e9bc5 lineage : < kgpl . Lineage object at 0x101417080 > url : < unregistered > annotations : []","title":"Variables"},{"location":"old/variables/#relationship-to-knowledge-graph-entities","text":"An object in an extant knowledge graph, such as Wikidata, can be viewed as a registered KGPL variable. For example, the Barack Obama URL at Wikidata (Q76) is a uniquely-identified variable that refers at any point in time to a particular value. That value has the Entity type. Most KGPL variables will never be registered. Most registered ones will never become well-known. But a small fraction will become well-known and potentially used by many. The current KGs can be thought of as sets of registered and well-known KGPL variables.","title":"Relationship to Knowledge Graph Entities"},{"location":"old/variables/#updates","text":"A KGPL variable can be updated whenever its owner decides it is appropriate. Some KGPL variables will be updated by social mechanisms -- basically, whenever a human wants to, the variable gets updated. Some will be updated according to a regular schedule, such as a variable that reflects a stock price, which gets updated every minute. Some will be updated according to external events, such as a temperature sensor reading. This update policy should be described in the human-readable part of a well-known variable. A KGPL variable can be updated by a process that is external to the KGPL universe. That is, external actors (social software, data feeds, etc) can publish variables \"into\" the KGPL variable space. But much of the time, a KGPL variable is updated because a KGPL program runs and changes the value. That's great! KGPL programs can register interest in their upstream variables. When the upstream variable is modified, the KGPL program may decide to re-execute.","title":"Updates"},{"location":"old/variables/#permissions","text":"KGPL variables are owned by a single user and registered at a single service. Unlike values, variables have a \"home service\". That service might be an internet-wide one, or limited to a particular group. Unlike value sharing, sharing a previously-private variable with an external party can only be done via changing access control to the home sharing service. Variables cannot be transmitted between sharing services.","title":"Permissions"}]}