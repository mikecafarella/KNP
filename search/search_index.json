{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Knowledge Network Programming System The Knowledge Network Programming System , or KNPS , is a programming system for building knowledge-powered applications. It allows users to more easily use existing knowledge and to curate new knowledge. It has two main components: The Knowledge Client allows users to easily specify a desired relational table, suitable for immediate application use. Specifying almost any desired table can be done in just a few lines of simple code. This table is automatically populated from a comprehensive back-end knowledge graph that includes raw data and data-processing functions on a vast range of topics. In most cases, the user can avoid the typical tedious process of data discovery, marshalling, cleaning, and curation. The Universal Knowledge Collaboration Network is the back-end knowledge graph that powers the Knowledge Client . In many ways it is similar to existing knowledge graphs like Wikidata and others: it hosts data, contains entities and properties, offers a variety of query interfaces, can host both well-known objects and unpopular objects, and relies on social processes for scalable curation. The UKCN is distinctive in that it contains a much wider array of datatypes than is typical: in addition to concrete entities, it can contain files, databases, schemas, properties, execution events, functions, and other items. As a result, the contents of the UKCN can model both the \"real\" world as well as the computational one.","title":"Welcome"},{"location":"#the-knowledge-network-programming-system","text":"The Knowledge Network Programming System , or KNPS , is a programming system for building knowledge-powered applications. It allows users to more easily use existing knowledge and to curate new knowledge. It has two main components: The Knowledge Client allows users to easily specify a desired relational table, suitable for immediate application use. Specifying almost any desired table can be done in just a few lines of simple code. This table is automatically populated from a comprehensive back-end knowledge graph that includes raw data and data-processing functions on a vast range of topics. In most cases, the user can avoid the typical tedious process of data discovery, marshalling, cleaning, and curation. The Universal Knowledge Collaboration Network is the back-end knowledge graph that powers the Knowledge Client . In many ways it is similar to existing knowledge graphs like Wikidata and others: it hosts data, contains entities and properties, offers a variety of query interfaces, can host both well-known objects and unpopular objects, and relies on social processes for scalable curation. The UKCN is distinctive in that it contains a much wider array of datatypes than is typical: in addition to concrete entities, it can contain files, databases, schemas, properties, execution events, functions, and other items. As a result, the contents of the UKCN can model both the \"real\" world as well as the computational one.","title":"The Knowledge Network Programming System"},{"location":"about/","text":"About the project! The Knowledge Network Programming System aims to make knowledge networks (graphs) easier to use and easier to build. We're grateful to the NSF Convergence Accelerator program and to Apple, Inc for funding the project.","title":"About"},{"location":"about/#about-the-project","text":"The Knowledge Network Programming System aims to make knowledge networks (graphs) easier to use and easier to build. We're grateful to the NSF Convergence Accelerator program and to Apple, Inc for funding the project.","title":"About the project!"},{"location":"api/","text":"API Documentation KGPLValue class knps.kgpl. KGPLValue ( val , comment , user='anonymous' , dependency=[] , vid=None , verbose=False ) Python representation of a KGPLValue. Users should not user the constructor to create a KGPLValue object directly. Instead, use the create_value function described below. Parameters val The concrete value stored in the KGPLValue object. comment A comment (of type str ) associated with this KGPLValue object. user Username of the owner of the KGPLValue object. dependency THe Dependency vid The unique identifier assigned by the server. verbose If set to true, more information is produced in the terminal. Otherwise, a succint description is printed when the construction succeeds. getVid ( self ) Return the vid getConcreteVal ( self ) Return the concrete value create_label ( self , label , comment ) Create a label to refer to this KGPLValue. Parameters label A label (of type str ) identifier for the value. Consider use label as a comment Descriptive comment for the value update_label ( self , label , new_comment ) Update the label for this KGPLValue Parameters label A new label identifier for the value comment A new comment KGPLVariable class knps.kgpl. KGPLVariable ( val_id , comment , vid , user='anonymous' , timestamp=None ) KGPLVariable object. Example:: # REPLACE THIS WITH REAL STUFF val = KGPLVariable('http://example.com') val.do_something() Parameters val_id Value ID comment User-readable comment about the variable vid What's a vid? user User timestamp Timestamp of the variable creation getVid ( self ) getValid ( self ) refresh ( self ) getConcreteVal ( self ) API Methods knps. kgpl create_value ( val , comment , user='anonymous' , dependency=[] , verbose=False ) value ( val , comment , user='anonymous' , dependency=[] , verbose=False ) variable ( var_id , val_id , comment , user='anonymous' ) load_val ( vid ) load_var ( vid ) set_var ( kg_var , val_id , new_comment ) Update a KGPLVariable and return it. Parameters kg_var KGPLVariable to be updated val_id ID of the KGPLValue the KGPLVariable should now point to new_comment Descriptive comment for the value get_history ( kg_var ) changeNamespace ( new_url ) viewNamespace ( ) get_label_content ( label )","title":"API Documentation"},{"location":"api/#api-documentation","text":"","title":"API Documentation"},{"location":"api/#kgplvalue","text":"class knps.kgpl. KGPLValue ( val , comment , user='anonymous' , dependency=[] , vid=None , verbose=False ) Python representation of a KGPLValue. Users should not user the constructor to create a KGPLValue object directly. Instead, use the create_value function described below.","title":"KGPLValue"},{"location":"api/#kgplvariable","text":"class knps.kgpl. KGPLVariable ( val_id , comment , vid , user='anonymous' , timestamp=None ) KGPLVariable object. Example:: # REPLACE THIS WITH REAL STUFF val = KGPLVariable('http://example.com') val.do_something()","title":"KGPLVariable"},{"location":"api/#api-methods","text":"knps. kgpl create_value ( val , comment , user='anonymous' , dependency=[] , verbose=False ) value ( val , comment , user='anonymous' , dependency=[] , verbose=False ) variable ( var_id , val_id , comment , user='anonymous' ) load_val ( vid ) load_var ( vid ) set_var ( kg_var , val_id , new_comment ) Update a KGPLVariable and return it.","title":"API Methods"},{"location":"install/","text":"Installation Here's how you install and run the Knowledge Client and the Universal Knowledge Collaboration Network . Move to the desired directory and clone the github repository using the code below git clone https://github.com/mikecafarella/KNP Use the following command to install the Knowledge Client package. This command will isntall the client package as knps and some required packages. You can use pip3 uninstall knps to remove the package. pip3 install -e client Up to now, the knps package is ready to go if you choose to use our server, use the following code in your program or python intepreter to import the package. The package APIs can be found at here . import knps To run a UKCN server locally, create a personal.yaml file in the repo root directory with the following contents, setting the address and port to your liking: server: SERVER_ADDRESS: 'http://127.0.0.1' SERVER_PORT: '4242' Use the following commands to configure the flask app and run the server export FLASK_APP=server/server.py flask run Tutorial Now that you've installed the system, try out the tutorial . reference 1","title":"Installation"},{"location":"install/#installation","text":"Here's how you install and run the Knowledge Client and the Universal Knowledge Collaboration Network . Move to the desired directory and clone the github repository using the code below git clone https://github.com/mikecafarella/KNP Use the following command to install the Knowledge Client package. This command will isntall the client package as knps and some required packages. You can use pip3 uninstall knps to remove the package. pip3 install -e client Up to now, the knps package is ready to go if you choose to use our server, use the following code in your program or python intepreter to import the package. The package APIs can be found at here . import knps To run a UKCN server locally, create a personal.yaml file in the repo root directory with the following contents, setting the address and port to your liking: server: SERVER_ADDRESS: 'http://127.0.0.1' SERVER_PORT: '4242' Use the following commands to configure the flask app and run the server export FLASK_APP=server/server.py flask run","title":"Installation"},{"location":"install/#tutorial","text":"Now that you've installed the system, try out the tutorial . reference 1","title":"Tutorial"},{"location":"knowledgeclient/","text":"The Knowledge Client This document describes the Knowledge Client , and how to use it to build data-powered applications very quickly. The main goal of the Knowledge Client is to allow users to quickly obtain a high-quality relation, on any topic. It is intended for integration into applications or data science workflows. The client obtains its data from the backing Universal Knowledge Collaboration Network . Users may have to consult the UKCN in order to find the right identifiers for data objects and properties. The current client is written in Python, though there is nothing Python-specific about it: future clients could be written to integrate with programs in Go, Rust, Swift, etc. Data Model A relation in both the Knowledge Client and the UKCN is akin to a traditional RDBMS relation: it's got rows and columns. However, our relations differ in two important ways: 1. Each row has a globally-unique identifier. This is roughly similar to the rowid that some database systems provide. However, our row ids are globally-unique identifiers. 2. Like a traditional RDBMS, each column has a human-understandable name (e.g., \"Salary\") and a type (e.g., \"float\"). In addition, in our system each column has a semantic label . These labels are drawn from a dictionary maintained by the UKCN . For example, a column might be annotated by a label /properties/wikidata/P3618 , which indicates \"base salary\". Execution Model The client allows the programmer to build a single relation at a time. The sequence of steps that the Knowledge Client performs can be thought of as a single \"table initialization step\", followed by a series of joins that grow the table's rows and columns. Some common kinds of initialization include: - Creating a table of a single row and a single column. For example, consider a single column that identifies a KG object, with a single row that represents the Barack Obama object. - Creating a table of many rows and a single column. For example, consider a single column that identifies a KG object, with multiple rows that represent members of a class, such as all instances of the City object. - Creating a table that corresponds to a pre-made table in the UKCN . For example, the programmer may grab a table of dollar-to-Euro exchange statistics. After initialization, the user performs a series of joins that potentially add rows and columns to the table. With some naming guidance from the user, the system synthesizes all of the appropriate column metadata for each new row and column. The system does not try to extract or clean UKCN data at the time of use, apart from a few important exceptions. At the individual fact level, everything the user sees inside a relation created by the Knowledge Client can be found in the UKCN . The exceptions surround cases when the system believes that facts in the UKCN are correct at the individual level, but will yield a relation that is internally inconsistent. Unfortunately, this is a well-known problem in knowledge graphs. Consider the example that Tim Berners-Lee is an example of Computer Scientist , while Computer Scientist is an example of profession . A Knowledge Client user trying to create a table of professions might inadvertently obtain one that includes Tim Berners-Lee . When appropriate, the Knowledge Client will either silently fix these issues, or will issue a warning to the user. Examples Let's try to show a few examples of using the Knowledge Client . Tutorial 1: Basic dataset construction with the presidents Dinghao, Tian, Kexin: can we add a simple example here? Just add basic entity data that's already in the knowledge graph. Presidents, their spouses, and their places and dates of birth. That's it. Tutorial 2: Adding numerical data from the European Union Dinghao, Tian, Kexin: here let's add a bit more complicated stuff. The European Union and GDP data. Then let's do inflation-adjustment for the GDP data. Tutorial 3: Whole-table functions with National Parks data Jenny, let's do the National Parks inception data here, and show how to do whole-table function invocation . REMINDER: WE NEED TO FIGURE OUT THE DATA MODEL DISTINCTION BETWEEN USING WIKIDATA VS USING THE SHARING SERVICE. RIGHT NOW THE CLIENT ONLY EXPLOITS WIKIDATA, BUT THIS SHOULD CHANGE VERY SOON.","title":"Knowledge Client"},{"location":"knowledgeclient/#the-knowledge-client","text":"This document describes the Knowledge Client , and how to use it to build data-powered applications very quickly. The main goal of the Knowledge Client is to allow users to quickly obtain a high-quality relation, on any topic. It is intended for integration into applications or data science workflows. The client obtains its data from the backing Universal Knowledge Collaboration Network . Users may have to consult the UKCN in order to find the right identifiers for data objects and properties. The current client is written in Python, though there is nothing Python-specific about it: future clients could be written to integrate with programs in Go, Rust, Swift, etc.","title":"The Knowledge Client"},{"location":"knowledgeclient/#data-model","text":"A relation in both the Knowledge Client and the UKCN is akin to a traditional RDBMS relation: it's got rows and columns. However, our relations differ in two important ways: 1. Each row has a globally-unique identifier. This is roughly similar to the rowid that some database systems provide. However, our row ids are globally-unique identifiers. 2. Like a traditional RDBMS, each column has a human-understandable name (e.g., \"Salary\") and a type (e.g., \"float\"). In addition, in our system each column has a semantic label . These labels are drawn from a dictionary maintained by the UKCN . For example, a column might be annotated by a label /properties/wikidata/P3618 , which indicates \"base salary\".","title":"Data Model"},{"location":"knowledgeclient/#execution-model","text":"The client allows the programmer to build a single relation at a time. The sequence of steps that the Knowledge Client performs can be thought of as a single \"table initialization step\", followed by a series of joins that grow the table's rows and columns. Some common kinds of initialization include: - Creating a table of a single row and a single column. For example, consider a single column that identifies a KG object, with a single row that represents the Barack Obama object. - Creating a table of many rows and a single column. For example, consider a single column that identifies a KG object, with multiple rows that represent members of a class, such as all instances of the City object. - Creating a table that corresponds to a pre-made table in the UKCN . For example, the programmer may grab a table of dollar-to-Euro exchange statistics. After initialization, the user performs a series of joins that potentially add rows and columns to the table. With some naming guidance from the user, the system synthesizes all of the appropriate column metadata for each new row and column. The system does not try to extract or clean UKCN data at the time of use, apart from a few important exceptions. At the individual fact level, everything the user sees inside a relation created by the Knowledge Client can be found in the UKCN . The exceptions surround cases when the system believes that facts in the UKCN are correct at the individual level, but will yield a relation that is internally inconsistent. Unfortunately, this is a well-known problem in knowledge graphs. Consider the example that Tim Berners-Lee is an example of Computer Scientist , while Computer Scientist is an example of profession . A Knowledge Client user trying to create a table of professions might inadvertently obtain one that includes Tim Berners-Lee . When appropriate, the Knowledge Client will either silently fix these issues, or will issue a warning to the user.","title":"Execution Model"},{"location":"knowledgeclient/#examples","text":"Let's try to show a few examples of using the Knowledge Client .","title":"Examples"},{"location":"knowledgeclient/#tutorial-1-basic-dataset-construction-with-the-presidents","text":"Dinghao, Tian, Kexin: can we add a simple example here? Just add basic entity data that's already in the knowledge graph. Presidents, their spouses, and their places and dates of birth. That's it.","title":"Tutorial 1: Basic dataset construction with the presidents"},{"location":"knowledgeclient/#tutorial-2-adding-numerical-data-from-the-european-union","text":"Dinghao, Tian, Kexin: here let's add a bit more complicated stuff. The European Union and GDP data. Then let's do inflation-adjustment for the GDP data.","title":"Tutorial 2: Adding numerical data from the European Union"},{"location":"knowledgeclient/#tutorial-3-whole-table-functions-with-national-parks-data","text":"Jenny, let's do the National Parks inception data here, and show how to do whole-table function invocation .","title":"Tutorial 3: Whole-table functions with National Parks data"},{"location":"knowledgeclient/#reminder","text":"WE NEED TO FIGURE OUT THE DATA MODEL DISTINCTION BETWEEN USING WIKIDATA VS USING THE SHARING SERVICE. RIGHT NOW THE CLIENT ONLY EXPLOITS WIKIDATA, BUT THIS SHOULD CHANGE VERY SOON.","title":"REMINDER:"},{"location":"lineage/","text":"Lineage A value's lineage is a directed tree that describes how the value was computed. A value node is annotated with its id or its url . Functions in KGPL always generate a special value of type Execution . This value contains a special field that identifies the source-function that generated it, along with an optional log message generated during execution. Values with a url can always have their details looked up at a KGPL sharing service . As a result, the lineage tree does not have to be fully-materialized; nodes with a url field just can be referred to and do not need to store further back history. This allows lineage trees, which might be quite large, to be made more compact. There is a single internet-wide KGPL service that will exist as soon as the language starts running.","title":"Lineage"},{"location":"lineage/#lineage","text":"A value's lineage is a directed tree that describes how the value was computed. A value node is annotated with its id or its url . Functions in KGPL always generate a special value of type Execution . This value contains a special field that identifies the source-function that generated it, along with an optional log message generated during execution. Values with a url can always have their details looked up at a KGPL sharing service . As a result, the lineage tree does not have to be fully-materialized; nodes with a url field just can be referred to and do not need to store further back history. This allows lineage trees, which might be quite large, to be made more compact. There is a single internet-wide KGPL service that will exist as soon as the language starts running.","title":"Lineage"},{"location":"restapi/","text":"REST API The UKCN offers a REST API for integration with existing data pipelines. This lets users and organizations who have data product jobs: - Obtain source data for data pipeline inputs - Upload new data pipeline outputs - Upload metadata about the pipeline execution itself TODO: Show examples of locally-running data production code. How you grab data, how you make new data, and how you upload metadata to the service. Try using the code that is in the COVID example.","title":"REST API"},{"location":"restapi/#rest-api","text":"The UKCN offers a REST API for integration with existing data pipelines. This lets users and organizations who have data product jobs: - Obtain source data for data pipeline inputs - Upload new data pipeline outputs - Upload metadata about the pipeline execution itself","title":"REST API"},{"location":"restapi/#todo","text":"Show examples of locally-running data production code. How you grab data, how you make new data, and how you upload metadata to the service. Try using the code that is in the COVID example.","title":"TODO:"},{"location":"sharingservice/","text":"The Univeral Knowledge Collaboration Network The UKCN is a knowledge graph that is similar to other Wikidata-style knowledge graphs. Like existing systems, it: - Hosts data - Contains entities and properties - Offers a range of query interfaces, such as SPARQL and the Knowledge Client - Hosts both well-known objects (e.g., Barack Obama) and obscure ones (e.g., a random uploaded image file) - Largely relies on social processes for data curation Unlike existing systems, the UKCN also models the computational world, with support for storing files, databases, schemas, execution events, functions, and other items. This allows the UKCN to apply the virtues of traditional knowledge graph systems --- topic flexibility and efficient curation --- to all the data that an application developer might need. Using the UKCN Like Wikidata, the UKCN presents an HTML browser interface for users. Anyone can search and retrieve data from the UKCN . With an account, a user can create new UKCN objects, annotate and edit existing ones, run functions, and carry out a range of other tasks. Every data object in the UKCN has its own URL. This URL can be used in the browser to find an object. The same URL can be provided to the Knowledge Client for various use cases. Sharing data with a colleague is as easy as sharing a webpage: just send your friend the appropriate URL. Every data object in the UKCN has an affiliated user account as its owner. In the current version of the UKCN , all data objects are world-readable and world-writable. Future versions will implement user permissions that prevent unauthorized access and edits. Data Model Data objects in UKCN are immutable: with one important exception, they can never change and are never deleted. Every immutable data object has an obscure identifier . This can be used to fetch the data object, forever. Because obscure identifers are never recycled, and because data objects can never be modified, UKCN can be used for long-term provenance tracking. An object with an obscure identifier is akin to a particular version of a particular entity in Wikidata; it might be useful and popular, but probably not. The UKCN also offers well-known identifiers . This is the only kind of value in the UKCN that can change over time. A well-known identifier starts with the letter 'X', followed by an integer. It is akin to the set of top-level entities in Wikidata, such as Q76 (Barack Obama). A well-known identifier always points to a single immutable data object (which, of course, also has an obscure identifier). This is similar to the way in which a high-level Wikidata identifier (e.g, Q76) at any moment in time points to a particular version of the entity. In practice, users can mostly ignore this distinction. Most people will mostly deal with well-known objects; that is, objects currently pointed-to by a well-known identifier . Non-well-known objects are generally only of interest when looking at past versions (e.g., for provenance tracking reasons). Users retrieving UKCN objects using a single query interface, whether its via an obscure identifier or a well-known identifier, Deployment There is a single UKCN that is implemented across multiple servers, in the same way there is a single World Wide Web implemented across multiple web servers. This will allow users and institutions to host data that might be tied to a particular location, while allowing users to ignore physical placement when annotating and curating data. However, the current UKCN software implements only \"single-server mode\". Interfaces The UKCN allows users to access it in three ways: 1. When building applications, via the Knowledge Client 2. When curating and sharing data, via the HTML Browser interface 3. When uploading novel data artifacts programmatically, via the REST API This last interface is primarily useful when integrating the UKCN with existing data pipelines. Getting Started Go here to install and run the UKCN system.","title":"Sharing Service"},{"location":"sharingservice/#the-univeral-knowledge-collaboration-network","text":"The UKCN is a knowledge graph that is similar to other Wikidata-style knowledge graphs. Like existing systems, it: - Hosts data - Contains entities and properties - Offers a range of query interfaces, such as SPARQL and the Knowledge Client - Hosts both well-known objects (e.g., Barack Obama) and obscure ones (e.g., a random uploaded image file) - Largely relies on social processes for data curation Unlike existing systems, the UKCN also models the computational world, with support for storing files, databases, schemas, execution events, functions, and other items. This allows the UKCN to apply the virtues of traditional knowledge graph systems --- topic flexibility and efficient curation --- to all the data that an application developer might need.","title":"The Univeral Knowledge Collaboration Network"},{"location":"sharingservice/#using-the-ukcn","text":"Like Wikidata, the UKCN presents an HTML browser interface for users. Anyone can search and retrieve data from the UKCN . With an account, a user can create new UKCN objects, annotate and edit existing ones, run functions, and carry out a range of other tasks. Every data object in the UKCN has its own URL. This URL can be used in the browser to find an object. The same URL can be provided to the Knowledge Client for various use cases. Sharing data with a colleague is as easy as sharing a webpage: just send your friend the appropriate URL. Every data object in the UKCN has an affiliated user account as its owner. In the current version of the UKCN , all data objects are world-readable and world-writable. Future versions will implement user permissions that prevent unauthorized access and edits.","title":"Using the UKCN"},{"location":"sharingservice/#data-model","text":"Data objects in UKCN are immutable: with one important exception, they can never change and are never deleted. Every immutable data object has an obscure identifier . This can be used to fetch the data object, forever. Because obscure identifers are never recycled, and because data objects can never be modified, UKCN can be used for long-term provenance tracking. An object with an obscure identifier is akin to a particular version of a particular entity in Wikidata; it might be useful and popular, but probably not. The UKCN also offers well-known identifiers . This is the only kind of value in the UKCN that can change over time. A well-known identifier starts with the letter 'X', followed by an integer. It is akin to the set of top-level entities in Wikidata, such as Q76 (Barack Obama). A well-known identifier always points to a single immutable data object (which, of course, also has an obscure identifier). This is similar to the way in which a high-level Wikidata identifier (e.g, Q76) at any moment in time points to a particular version of the entity. In practice, users can mostly ignore this distinction. Most people will mostly deal with well-known objects; that is, objects currently pointed-to by a well-known identifier . Non-well-known objects are generally only of interest when looking at past versions (e.g., for provenance tracking reasons). Users retrieving UKCN objects using a single query interface, whether its via an obscure identifier or a well-known identifier,","title":"Data Model"},{"location":"sharingservice/#deployment","text":"There is a single UKCN that is implemented across multiple servers, in the same way there is a single World Wide Web implemented across multiple web servers. This will allow users and institutions to host data that might be tied to a particular location, while allowing users to ignore physical placement when annotating and curating data. However, the current UKCN software implements only \"single-server mode\".","title":"Deployment"},{"location":"sharingservice/#interfaces","text":"The UKCN allows users to access it in three ways: 1. When building applications, via the Knowledge Client 2. When curating and sharing data, via the HTML Browser interface 3. When uploading novel data artifacts programmatically, via the REST API This last interface is primarily useful when integrating the UKCN with existing data pipelines.","title":"Interfaces"},{"location":"sharingservice/#getting-started","text":"Go here to install and run the UKCN system.","title":"Getting Started"},{"location":"tutorial/","text":"Tutorial and Walkthrough We will walk through an example of adding data to the UKCN and then using it in the Knowledge Client . You should have already installed the software. If not, go follow the installation instructions . Jiayun, Yitong, Yuning, can we add the programmatic COVID example here? It should be the written-out version of the tutorial video.","title":"Tutorial"},{"location":"tutorial/#tutorial-and-walkthrough","text":"We will walk through an example of adding data to the UKCN and then using it in the Knowledge Client . You should have already installed the software. If not, go follow the installation instructions . Jiayun, Yitong, Yuning, can we add the programmatic COVID example here? It should be the written-out version of the tutorial video.","title":"Tutorial and Walkthrough"}]}