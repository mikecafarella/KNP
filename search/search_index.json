{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Knowledge Network Programming System The Knowledge Network Programming System , or KNPS , is a programming system for building knowledge-powered applications. It allows users to more easily use existing knowledge and to curate new knowledge. It has two main components: The Knowledge Client allows users to easily specify a desired relational table, suitable for immediate application use. Specifying almost any desired table can be done in just a few lines of simple code. This table is automatically populated from a comprehensive back-end knowledge graph that includes raw data and data-processing functions on a vast range of topics. In most cases, the user can avoid the typical tedious process of data discovery, marshalling, cleaning, and curation. The Universal Knowledge Collaboration Network is the back-end knowledge graph that powers the Knowledge Client . In many ways it is similar to existing knowledge graphs like Wikidata and others: it hosts data, contains entities and properties, offers a variety of query interfaces, can host both well-known objects and unpopular objects, and relies on social processes for scalable curation. The UKCN is distinctive in that it contains a much wider array of datatypes than is typical: in addition to concrete entities, it can contain files, databases, schemas, properties, execution events, functions, and other items. As a result, the contents of the UKCN can model both the \"real\" world as well as the computational one.","title":"Welcome"},{"location":"#the-knowledge-network-programming-system","text":"The Knowledge Network Programming System , or KNPS , is a programming system for building knowledge-powered applications. It allows users to more easily use existing knowledge and to curate new knowledge. It has two main components: The Knowledge Client allows users to easily specify a desired relational table, suitable for immediate application use. Specifying almost any desired table can be done in just a few lines of simple code. This table is automatically populated from a comprehensive back-end knowledge graph that includes raw data and data-processing functions on a vast range of topics. In most cases, the user can avoid the typical tedious process of data discovery, marshalling, cleaning, and curation. The Universal Knowledge Collaboration Network is the back-end knowledge graph that powers the Knowledge Client . In many ways it is similar to existing knowledge graphs like Wikidata and others: it hosts data, contains entities and properties, offers a variety of query interfaces, can host both well-known objects and unpopular objects, and relies on social processes for scalable curation. The UKCN is distinctive in that it contains a much wider array of datatypes than is typical: in addition to concrete entities, it can contain files, databases, schemas, properties, execution events, functions, and other items. As a result, the contents of the UKCN can model both the \"real\" world as well as the computational one.","title":"The Knowledge Network Programming System"},{"location":"about/","text":"About the project! The Knowledge Network Programming System aims to make knowledge networks (graphs) easier to use and easier to build. We're grateful to the NSF Convergence Accelerator program and to Apple, Inc for funding the project.","title":"About"},{"location":"about/#about-the-project","text":"The Knowledge Network Programming System aims to make knowledge networks (graphs) easier to use and easier to build. We're grateful to the NSF Convergence Accelerator program and to Apple, Inc for funding the project.","title":"About the project!"},{"location":"api/","text":"API Documentation File class knps. File ( filename ) File wrapper class. This wrapper class should be used when storing a file into a KGPLValue object. Parameters filename The absolute or relative path to the file . Example import knps file = knps.File(\"picture.png\") kgplvalue = knps.create_values(file, \"a picture\") KGPLValue class knps. KGPLValue ( val , comment , user='anonymous' , dependency=[] , vid=None , verbose=False ) Python representation of a KGPLValue. Users should not user the constructor to create a KGPLValue object directly. Instead, use the create_value function described below. Parameters val The concrete value stored in the KGPLValue object. comment A user-readable comment (of type str ) associated with this KGPLValue object. user Username of the owner of the KGPLValue object. dependency A list consisting of the KGPL objects that this KGPLValue depended on. vid The unique identifier assigned by the server. verbose If set to true, more information is produced in the terminal. Otherwise, a succint description is printed when the construction succeeds. getVid ( self ) Return the vid getConcreteVal ( self ) Return the concrete value create_label ( self , label , comment ) Create a label to refer to this KGPLValue. Parameters label A label (of type str ) identifier for the value. Consider use label as a comment Descriptive comment for the label creation Return The KGPLVariable object that underlies the label update_label ( self , label , new_comment ) Update the input label with this KGPLValue Parameters label The label to be updated comment Descriptive comment for the label update Return The KGPLVariable object that underlies the label KGPLVariable class knps. KGPLVariable ( val_id , comment , vid , user='anonymous' , timestamp=None ) Python representation of a KGPLVariable. Users should not user the constructor to create a KGPLVariable object directly. Instead, use the variable function described below. Parameters val_id The vid of the KGPLValue to be stored comment A user-readable comment (of type str ) associated with this KGPLVariable object. vid The unique identifier assigned by the server. user Username of the owner of the KGPLVariable object. timestamp Timestamp of the variable creation getVid ( self ) Get the vid Return the vid of this KGPLVariable. getValid ( self ) Get the vid of the contained KGPLValue Return the vid of the KGPLValue this variable refers to. refresh ( self ) Synchronize with the server to get the newest state of the variable in case of users work on the same variable concurrently. getConcreteVal ( self ) Get the KGPLValue stored in this KGPLVariable object Return - The KGPLValue object stored in this variable API Methods knps. kgpl create_value ( val , comment , user='anonymous' , dependency=[] , verbose=False ) Create a KGPLValue based on the inputs and publish to the server. Parameter 'val' Concrete value to store (We currently support the following types: int , float , bool , list , dict , File , pandas.DataFrame , Relation ) 'comment' A human readable comment (of type str ) associated with the value creattion 'user' User name of the owner of the KGPLValue, the default value is anonymous dependency A list consisting of the KGPL objects that this KGPLValue depended on. Each element in the list can be one of the three types: KGPLValue , KGPLVariable or Label . The default value is empty list. verbose : If set to true, more information is produced in the terminal. Otherwise, a succint description is printed when the construction succeeds. The default value is False . Return A KGPLValue object constructed based on inputs publish_new ( val , comment , label=None , user='anonymous' , dependency=[] , verbose=False , label_comment='' ) Create a KGPLValue based on the inputs and publish to the server, then create and return a label for this KGPLValue. Parameter val Concrete value to store (We currently support the following types: int , float , bool , list , dict , File , pandas.DataFrame , Relation ) comment A human readable comment (of type str ) associated with the value creation label A human readable name to refer to the new KGPLValue. The default value is None . In that case, a default label is generated by the server. user User name of the owner of this operation, the default value is anonymous dependency A list consisting of the KGPL objects that this KGPLValue depended on. Each element in the list can be one of the three types: KGPLValue , KGPLVariable or Label . The default value is empty list. verbose : If set to true, more information is produced in the terminal. Otherwise, a succint description is printed when the construction succeeds. The default value is False . 'label_comment' A human readable comment (of type str ) associated with the label creation Return A KGPLVariable object constructed based on inputs load_val ( vid ) Fetch the KGPLValue of the corresponding vid Parameter vid The vid of the desired KGPLValue Return A KGPLValue object publish_update ( val , comment , label , user='anonymous' , dependency=[] , verbose=False , label_comment='' ) Create a KGPLValue based on the inputs and publish to the server, then update and return the label for this KGPLValue. Parameter val Concrete value to store (We currently support the following types: int , float , bool , list , dict , File , pandas.DataFrame , Relation ) comment A human readable comment (of type str ) associated with the value creation label The label being updated user User name of the owner of this operation, the default value is anonymous dependency A list consisting of the KGPL objects that this KGPLValue depended on. Each element in the list can be one of the three types: KGPLValue , KGPLVariable or Label . The default value is empty list. verbose : If set to true, more information is produced in the terminal. Otherwise, a succint description is printed when the construction succeeds. The default value is False . 'label_comment' A human readable comment (of type str ) associated with the label update Return A KGPLVariable object updated based on inputs get_label_content ( label ) Get the content underlying a label Parameter label The label being fetched Return A KGPLVariable object this label represents get_history ( kg_var ) Fetch the history information of a KGPLVariable object from server Parameter kg_var : KGPLVariable object whose history information is of interest Return A list of vids this variable has refered to. The first element is the newest state while the last element is the oldest state. check_label_occupied ( vid ) Check the server to determine if the label is occupied. Parameter vid The label name to check changeNamespace ( new_url ) change the namespace of the current program. Parameter new_url the new namespace viewNamespace ( ) print the current namespace","title":"API Documentation"},{"location":"api/#api-documentation","text":"","title":"API Documentation"},{"location":"api/#file","text":"class knps. File ( filename ) File wrapper class. This wrapper class should be used when storing a file into a KGPLValue object.","title":"File"},{"location":"api/#kgplvalue","text":"class knps. KGPLValue ( val , comment , user='anonymous' , dependency=[] , vid=None , verbose=False ) Python representation of a KGPLValue. Users should not user the constructor to create a KGPLValue object directly. Instead, use the create_value function described below.","title":"KGPLValue"},{"location":"api/#kgplvariable","text":"class knps. KGPLVariable ( val_id , comment , vid , user='anonymous' , timestamp=None ) Python representation of a KGPLVariable. Users should not user the constructor to create a KGPLVariable object directly. Instead, use the variable function described below.","title":"KGPLVariable"},{"location":"api/#api-methods","text":"knps. kgpl create_value ( val , comment , user='anonymous' , dependency=[] , verbose=False ) Create a KGPLValue based on the inputs and publish to the server.","title":"API Methods"},{"location":"install/","text":"Installation Here's how you install and run the Knowledge Client and the Universal Knowledge Collaboration Network . Move to the desired directory and clone the github repository using the code below git clone https://github.com/mikecafarella/KNP Use the following command to install the Knowledge Client package. This command will isntall the client package as knps and some required packages. You can use pip3 uninstall knps to remove the package. pip3 install -e client Up to now, the knps package is ready to go if you choose to use our server, use the following code in your program or python intepreter to import the package. The package APIs can be found at here . import knps To run a UKCN server locally, create a personal.yaml file in the repo root directory with the following contents, setting the address and port to your liking: server: SERVER_ADDRESS: 'http://127.0.0.1' SERVER_PORT: '4242' Use the following commands to configure the flask app and run the server export FLASK_APP=server/server.py flask run Tutorial Now that you've installed the system, try out the tutorial .","title":"Installation"},{"location":"install/#installation","text":"Here's how you install and run the Knowledge Client and the Universal Knowledge Collaboration Network . Move to the desired directory and clone the github repository using the code below git clone https://github.com/mikecafarella/KNP Use the following command to install the Knowledge Client package. This command will isntall the client package as knps and some required packages. You can use pip3 uninstall knps to remove the package. pip3 install -e client Up to now, the knps package is ready to go if you choose to use our server, use the following code in your program or python intepreter to import the package. The package APIs can be found at here . import knps To run a UKCN server locally, create a personal.yaml file in the repo root directory with the following contents, setting the address and port to your liking: server: SERVER_ADDRESS: 'http://127.0.0.1' SERVER_PORT: '4242' Use the following commands to configure the flask app and run the server export FLASK_APP=server/server.py flask run","title":"Installation"},{"location":"install/#tutorial","text":"Now that you've installed the system, try out the tutorial .","title":"Tutorial"},{"location":"knowledgeclient/","text":"The Knowledge Client This document describes the Knowledge Client , and how to use it to build data-powered applications very quickly. The main goal of the Knowledge Client is to allow users to quickly obtain a high-quality relation, on any topic. It is intended for integration into applications or data science workflows. The client obtains its data from the backing Universal Knowledge Collaboration Network . Users may have to consult the UKCN in order to find the right identifiers for data objects and properties. The current client is written in Python, though there is nothing Python-specific about it: future clients could be written to integrate with programs in Go, Rust, Swift, etc. Data Model A relation in both the Knowledge Client and the UKCN is akin to a traditional RDBMS relation: it's got rows and columns. However, our relations differ in two important ways: 1. Each row has a globally-unique identifier. This is roughly similar to the rowid that some database systems provide. However, our row ids are globally-unique identifiers. 2. Like a traditional RDBMS, each column has a human-understandable name (e.g., \"Salary\") and a type (e.g., \"float\"). In addition, in our system each column has a semantic label . These labels are drawn from a dictionary maintained by the UKCN . For example, a column might be annotated by a label /properties/wikidata/P3618 , which indicates \"base salary\". Execution Model The client allows the programmer to build a single relation at a time. The sequence of steps that the Knowledge Client performs can be thought of as a single \"table initialization step\", followed by a series of joins that grow the table's rows and columns. Some common kinds of initialization include: - Creating a table of a single row and a single column. For example, consider a single column that identifies a KG object, with a single row that represents the Barack Obama object. - Creating a table of many rows and a single column. For example, consider a single column that identifies a KG object, with multiple rows that represent members of a class, such as all instances of the City object. - Creating a table that corresponds to a pre-made table in the UKCN . For example, the programmer may grab a table of dollar-to-Euro exchange statistics. After initialization, the user performs a series of joins that potentially add rows and columns to the table. With some naming guidance from the user, the system synthesizes all of the appropriate column metadata for each new row and column. The system does not try to extract or clean UKCN data at the time of use, apart from a few important exceptions. At the individual fact level, everything the user sees inside a relation created by the Knowledge Client can be found in the UKCN . The exceptions surround cases when the system believes that facts in the UKCN are correct at the individual level, but will yield a relation that is internally inconsistent. Unfortunately, this is a well-known problem in knowledge graphs. Consider the example that Tim Berners-Lee is an example of Computer Scientist , while Computer Scientist is an example of profession . A Knowledge Client user trying to create a table of professions might inadvertently obtain one that includes Tim Berners-Lee . When appropriate, the Knowledge Client will either silently fix these issues, or will issue a warning to the user. Examples Let's try to show a few examples of using the Knowledge Client . Tutorial 1: Basic dataset construction with the presidents Dinghao, Tian, Kexin: can we add a simple example here? Just add basic entity data that's already in the knowledge graph. Presidents, their spouses, and their places and dates of birth. That's it. Construct a relation of US presidents, their spouses, their dates of birth and places of births: r = createRelation('Q11696') # Q11696 - 'President of the United States' in wikidata r.extend('P39',True, 'President', limit=20, label=True) # P39 - 'position held' r.changeFocus('President_P39') r.extend('P26', False, 'Spouse', label=True) # P26 - 'spouse' r.extend('P569', False, 'date_of_birth', label=True) # P569 - 'date of birth' r.extend('P19',False, 'Place_of_birth', label=True) #P19 - 'place of birth' r.query() r.df Sample Results: | Entity ID | President_P39 | President_P39Label | Spouse_P26 | Spouse_P26Label | date_of_birth_P569 | date_of_birth_P569Label | Place_of_birth_P19 | Place_of_birth_P19Label | Basic ID | | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | | http://www.wikidata.org/entity/Q11696 | http://www.wikidata.org/entity/Q35686 | Rutherford B. Hayes | http://www.wikidata.org/entity/Q234275 | Lucy Webb Hayes | 1822-10-04T00:00:00Z | 1822-10-04T00:00:00Z | http://www.wikidata.org/entity/Q934308 | Fremont | Q11696 | | http://www.wikidata.org/entity/Q11696 | http://www.wikidata.org/entity/Q35171 | Grover Cleveland | http://www.wikidata.org/entity/Q233644 | Frances Cleveland | 1837-03-18T00:00:00Z | 1837-03-18T00:00:00Z | http://www.wikidata.org/entity/Q717516 | Caldwell | Q11696 | Tutorial 2: Adding numerical data from the European Union Dinghao, Tian, Kexin: here let's add a bit more complicated stuff. The European Union and GDP data. Then let's do inflation-adjustment for the GDP data. Here is an example of all countries in the European Union and their population, as well as the population of the whole Europe: r = createRelation('Q458') # Q458 - 'European Union' in wikidata r.extend('P150',False,'Countries',label=True) # P150 - 'contains administrative territorial entity' r.extend('P1082',False, 'Total_population') # P1082 - 'Population' r.changeFocus('Countries_P150') r.extend('P1082',False, 'population') r.query() r.df Sample Results: | Entity ID | Countries_P150 | Countries_P150Label | Total_population_P1082 | population_P1082 | Basic ID | | :----: | :----: | :----: | :----: | :----: | :----: | | http://www.wikidata.org/entity/Q458 | http://www.wikidata.org/entity/Q219 | Bulgaria | 447706209 | 7000039 | Q458 | | http://www.wikidata.org/entity/Q458 | http://www.wikidata.org/entity/Q33 | Finland | 447706209 | 5501043 | Q458 | Here is another example of inflation-adjusted US GDP data, with the base year of 2014: import math def adjustedGDP(gdp: WikiDataProperty(['P2131', 'P2132']), timestamp: WikiDataProperty(['P585'])): inflationIndex = pd.read_csv('inflation_data_found_online.csv') base = inflationIndex.iloc[-1]['Index'] timestamp = timestamp[:10] inflationIndex.set_index('Date',inplace=True) if timestamp in inflationIndex.index: return math.floor(float(gdp) / inflationIndex.loc[timestamp]['Index'] * base) return math.floor(float(gdp)) usgdp = createRelation('Q30') # Q30 - 'United States of America' usgdp.extend('P2131', False, 'GDP', colVerbose=True,rowVerbose=True) # P2131 - 'nominal GDP' usgdp.query() usgdp.extendWithFunction(['GDP_P2131','GDP_point_in_time_P2131_P585'], adjustedGDP, 'adjustedGDP_P2131') # base 2014 usgdp.df Sample Results: | Entity ID | GDP_P2131 | GDP_rank_P2131_rank | GDP_point_in_time_P2131_P585 | GDP_ref_P2131_P813 | GDP_ref_P2131_P248 | GDP_ref_P2131_P275 | GDP_ref_P2131_P854 | Basic ID | adjustedGDP_P2131 | | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | | http://www.wikidata.org/entity/Q30 | 16155255000000 | http://wikiba.se/ontology#NormalRank | 2012-01-01T00:00:00Z | 2018-10-18T00:00:00Z | http://www.wikidata.org/entity/Q21540096 | http://www.wikidata.org/entity/Q20007257 | https://data.worldbank.org/indicator/NY.GDP.MK... | Q30 | 16672060655946 | | http://www.wikidata.org/entity/Q30 | 1167770000000 | http://wikiba.se/ontology#NormalRank | 1971-01-01T00:00:00Z | 2018-10-18T00:00:00Z | http://www.wikidata.org/entity/Q21540096 | http://www.wikidata.org/entity/Q20007257 | https://data.worldbank.org/indicator/NY.GDP.MK... | Q30 | 6863318776884 | Tutorial 3: Whole-table functions with National Parks data Jenny, let's do the National Parks inception data here, and show how to do whole-table function invocation . REMINDER: WE NEED TO FIGURE OUT THE DATA MODEL DISTINCTION BETWEEN USING WIKIDATA VS USING THE SHARING SERVICE. RIGHT NOW THE CLIENT ONLY EXPLOITS WIKIDATA, BUT THIS SHOULD CHANGE VERY SOON.","title":"Knowledge Client"},{"location":"knowledgeclient/#the-knowledge-client","text":"This document describes the Knowledge Client , and how to use it to build data-powered applications very quickly. The main goal of the Knowledge Client is to allow users to quickly obtain a high-quality relation, on any topic. It is intended for integration into applications or data science workflows. The client obtains its data from the backing Universal Knowledge Collaboration Network . Users may have to consult the UKCN in order to find the right identifiers for data objects and properties. The current client is written in Python, though there is nothing Python-specific about it: future clients could be written to integrate with programs in Go, Rust, Swift, etc.","title":"The Knowledge Client"},{"location":"knowledgeclient/#data-model","text":"A relation in both the Knowledge Client and the UKCN is akin to a traditional RDBMS relation: it's got rows and columns. However, our relations differ in two important ways: 1. Each row has a globally-unique identifier. This is roughly similar to the rowid that some database systems provide. However, our row ids are globally-unique identifiers. 2. Like a traditional RDBMS, each column has a human-understandable name (e.g., \"Salary\") and a type (e.g., \"float\"). In addition, in our system each column has a semantic label . These labels are drawn from a dictionary maintained by the UKCN . For example, a column might be annotated by a label /properties/wikidata/P3618 , which indicates \"base salary\".","title":"Data Model"},{"location":"knowledgeclient/#execution-model","text":"The client allows the programmer to build a single relation at a time. The sequence of steps that the Knowledge Client performs can be thought of as a single \"table initialization step\", followed by a series of joins that grow the table's rows and columns. Some common kinds of initialization include: - Creating a table of a single row and a single column. For example, consider a single column that identifies a KG object, with a single row that represents the Barack Obama object. - Creating a table of many rows and a single column. For example, consider a single column that identifies a KG object, with multiple rows that represent members of a class, such as all instances of the City object. - Creating a table that corresponds to a pre-made table in the UKCN . For example, the programmer may grab a table of dollar-to-Euro exchange statistics. After initialization, the user performs a series of joins that potentially add rows and columns to the table. With some naming guidance from the user, the system synthesizes all of the appropriate column metadata for each new row and column. The system does not try to extract or clean UKCN data at the time of use, apart from a few important exceptions. At the individual fact level, everything the user sees inside a relation created by the Knowledge Client can be found in the UKCN . The exceptions surround cases when the system believes that facts in the UKCN are correct at the individual level, but will yield a relation that is internally inconsistent. Unfortunately, this is a well-known problem in knowledge graphs. Consider the example that Tim Berners-Lee is an example of Computer Scientist , while Computer Scientist is an example of profession . A Knowledge Client user trying to create a table of professions might inadvertently obtain one that includes Tim Berners-Lee . When appropriate, the Knowledge Client will either silently fix these issues, or will issue a warning to the user.","title":"Execution Model"},{"location":"knowledgeclient/#examples","text":"Let's try to show a few examples of using the Knowledge Client .","title":"Examples"},{"location":"knowledgeclient/#tutorial-1-basic-dataset-construction-with-the-presidents","text":"Dinghao, Tian, Kexin: can we add a simple example here? Just add basic entity data that's already in the knowledge graph. Presidents, their spouses, and their places and dates of birth. That's it. Construct a relation of US presidents, their spouses, their dates of birth and places of births: r = createRelation('Q11696') # Q11696 - 'President of the United States' in wikidata r.extend('P39',True, 'President', limit=20, label=True) # P39 - 'position held' r.changeFocus('President_P39') r.extend('P26', False, 'Spouse', label=True) # P26 - 'spouse' r.extend('P569', False, 'date_of_birth', label=True) # P569 - 'date of birth' r.extend('P19',False, 'Place_of_birth', label=True) #P19 - 'place of birth' r.query() r.df Sample Results: | Entity ID | President_P39 | President_P39Label | Spouse_P26 | Spouse_P26Label | date_of_birth_P569 | date_of_birth_P569Label | Place_of_birth_P19 | Place_of_birth_P19Label | Basic ID | | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | | http://www.wikidata.org/entity/Q11696 | http://www.wikidata.org/entity/Q35686 | Rutherford B. Hayes | http://www.wikidata.org/entity/Q234275 | Lucy Webb Hayes | 1822-10-04T00:00:00Z | 1822-10-04T00:00:00Z | http://www.wikidata.org/entity/Q934308 | Fremont | Q11696 | | http://www.wikidata.org/entity/Q11696 | http://www.wikidata.org/entity/Q35171 | Grover Cleveland | http://www.wikidata.org/entity/Q233644 | Frances Cleveland | 1837-03-18T00:00:00Z | 1837-03-18T00:00:00Z | http://www.wikidata.org/entity/Q717516 | Caldwell | Q11696 |","title":"Tutorial 1: Basic dataset construction with the presidents"},{"location":"knowledgeclient/#tutorial-2-adding-numerical-data-from-the-european-union","text":"Dinghao, Tian, Kexin: here let's add a bit more complicated stuff. The European Union and GDP data. Then let's do inflation-adjustment for the GDP data. Here is an example of all countries in the European Union and their population, as well as the population of the whole Europe: r = createRelation('Q458') # Q458 - 'European Union' in wikidata r.extend('P150',False,'Countries',label=True) # P150 - 'contains administrative territorial entity' r.extend('P1082',False, 'Total_population') # P1082 - 'Population' r.changeFocus('Countries_P150') r.extend('P1082',False, 'population') r.query() r.df Sample Results: | Entity ID | Countries_P150 | Countries_P150Label | Total_population_P1082 | population_P1082 | Basic ID | | :----: | :----: | :----: | :----: | :----: | :----: | | http://www.wikidata.org/entity/Q458 | http://www.wikidata.org/entity/Q219 | Bulgaria | 447706209 | 7000039 | Q458 | | http://www.wikidata.org/entity/Q458 | http://www.wikidata.org/entity/Q33 | Finland | 447706209 | 5501043 | Q458 | Here is another example of inflation-adjusted US GDP data, with the base year of 2014: import math def adjustedGDP(gdp: WikiDataProperty(['P2131', 'P2132']), timestamp: WikiDataProperty(['P585'])): inflationIndex = pd.read_csv('inflation_data_found_online.csv') base = inflationIndex.iloc[-1]['Index'] timestamp = timestamp[:10] inflationIndex.set_index('Date',inplace=True) if timestamp in inflationIndex.index: return math.floor(float(gdp) / inflationIndex.loc[timestamp]['Index'] * base) return math.floor(float(gdp)) usgdp = createRelation('Q30') # Q30 - 'United States of America' usgdp.extend('P2131', False, 'GDP', colVerbose=True,rowVerbose=True) # P2131 - 'nominal GDP' usgdp.query() usgdp.extendWithFunction(['GDP_P2131','GDP_point_in_time_P2131_P585'], adjustedGDP, 'adjustedGDP_P2131') # base 2014 usgdp.df Sample Results: | Entity ID | GDP_P2131 | GDP_rank_P2131_rank | GDP_point_in_time_P2131_P585 | GDP_ref_P2131_P813 | GDP_ref_P2131_P248 | GDP_ref_P2131_P275 | GDP_ref_P2131_P854 | Basic ID | adjustedGDP_P2131 | | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | | http://www.wikidata.org/entity/Q30 | 16155255000000 | http://wikiba.se/ontology#NormalRank | 2012-01-01T00:00:00Z | 2018-10-18T00:00:00Z | http://www.wikidata.org/entity/Q21540096 | http://www.wikidata.org/entity/Q20007257 | https://data.worldbank.org/indicator/NY.GDP.MK... | Q30 | 16672060655946 | | http://www.wikidata.org/entity/Q30 | 1167770000000 | http://wikiba.se/ontology#NormalRank | 1971-01-01T00:00:00Z | 2018-10-18T00:00:00Z | http://www.wikidata.org/entity/Q21540096 | http://www.wikidata.org/entity/Q20007257 | https://data.worldbank.org/indicator/NY.GDP.MK... | Q30 | 6863318776884 |","title":"Tutorial 2: Adding numerical data from the European Union"},{"location":"knowledgeclient/#tutorial-3-whole-table-functions-with-national-parks-data","text":"Jenny, let's do the National Parks inception data here, and show how to do whole-table function invocation .","title":"Tutorial 3: Whole-table functions with National Parks data"},{"location":"knowledgeclient/#reminder","text":"WE NEED TO FIGURE OUT THE DATA MODEL DISTINCTION BETWEEN USING WIKIDATA VS USING THE SHARING SERVICE. RIGHT NOW THE CLIENT ONLY EXPLOITS WIKIDATA, BUT THIS SHOULD CHANGE VERY SOON.","title":"REMINDER:"},{"location":"lineage/","text":"Lineage A value's lineage is a directed tree that describes how the value was computed. A value node is annotated with its id or its url . Functions in KGPL always generate a special value of type Execution . This value contains a special field that identifies the source-function that generated it, along with an optional log message generated during execution. Values with a url can always have their details looked up at a KGPL sharing service . As a result, the lineage tree does not have to be fully-materialized; nodes with a url field just can be referred to and do not need to store further back history. This allows lineage trees, which might be quite large, to be made more compact. There is a single internet-wide KGPL service that will exist as soon as the language starts running.","title":"Lineage"},{"location":"lineage/#lineage","text":"A value's lineage is a directed tree that describes how the value was computed. A value node is annotated with its id or its url . Functions in KGPL always generate a special value of type Execution . This value contains a special field that identifies the source-function that generated it, along with an optional log message generated during execution. Values with a url can always have their details looked up at a KGPL sharing service . As a result, the lineage tree does not have to be fully-materialized; nodes with a url field just can be referred to and do not need to store further back history. This allows lineage trees, which might be quite large, to be made more compact. There is a single internet-wide KGPL service that will exist as soon as the language starts running.","title":"Lineage"},{"location":"restapi/","text":"REST API The UKCN offers a REST API for integration with existing data pipelines. This lets users and organizations who have data product jobs: - Obtain source data for data pipeline inputs - Upload new data pipeline outputs - Upload metadata about the pipeline execution itself TODO: Show examples of locally-running data production code. How you grab data, how you make new data, and how you upload metadata to the service. Try using the code that is in the COVID example.","title":"REST API"},{"location":"restapi/#rest-api","text":"The UKCN offers a REST API for integration with existing data pipelines. This lets users and organizations who have data product jobs: - Obtain source data for data pipeline inputs - Upload new data pipeline outputs - Upload metadata about the pipeline execution itself","title":"REST API"},{"location":"restapi/#todo","text":"Show examples of locally-running data production code. How you grab data, how you make new data, and how you upload metadata to the service. Try using the code that is in the COVID example.","title":"TODO:"},{"location":"sharingservice/","text":"The Univeral Knowledge Collaboration Network The UKCN is a knowledge graph that is similar to other Wikidata-style knowledge graphs. Like existing systems, it: - Hosts data - Contains entities and properties - Offers a range of query interfaces, such as SPARQL and the Knowledge Client - Hosts both well-known objects (e.g., Barack Obama) and obscure ones (e.g., a random uploaded image file) - Largely relies on social processes for data curation Unlike existing systems, the UKCN also models the computational world, with support for storing files, databases, schemas, execution events, functions, and other items. This allows the UKCN to apply the virtues of traditional knowledge graph systems --- topic flexibility and efficient curation --- to all the data that an application developer might need. Using the UKCN Like Wikidata, the UKCN presents an HTML browser interface for users. Anyone can search and retrieve data from the UKCN . With an account, a user can create new UKCN objects, annotate and edit existing ones, run functions, and carry out a range of other tasks. Every data object in the UKCN has its own URL. This URL can be used in the browser to find an object. The same URL can be provided to the Knowledge Client for various use cases. Sharing data with a colleague is as easy as sharing a webpage: just send your friend the appropriate URL. Every data object in the UKCN has an affiliated user account as its owner. In the current version of the UKCN , all data objects are world-readable and world-writable. Future versions will implement user permissions that prevent unauthorized access and edits. Data Model Data objects in UKCN are immutable: with one important exception, they can never change and are never deleted. Every immutable data object has an obscure identifier . This can be used to fetch the data object, forever. Because obscure identifers are never recycled, and because data objects can never be modified, UKCN can be used for long-term provenance tracking. An object with an obscure identifier is akin to a particular version of a particular entity in Wikidata; it might be useful and popular, but probably not. The UKCN also offers well-known identifiers . This is the only kind of value in the UKCN that can change over time. A well-known identifier starts with the letter 'X', followed by an integer. It is akin to the set of top-level entities in Wikidata, such as Q76 (Barack Obama). A well-known identifier always points to a single immutable data object (which, of course, also has an obscure identifier). This is similar to the way in which a high-level Wikidata identifier (e.g, Q76) at any moment in time points to a particular version of the entity. In practice, users can mostly ignore this distinction. Most people will mostly deal with well-known objects; that is, objects currently pointed-to by a well-known identifier . Non-well-known objects are generally only of interest when looking at past versions (e.g., for provenance tracking reasons). Users retrieving UKCN objects using a single query interface, whether its via an obscure identifier or a well-known identifier, Deployment There is a single UKCN that is implemented across multiple servers, in the same way there is a single World Wide Web implemented across multiple web servers. This will allow users and institutions to host data that might be tied to a particular location, while allowing users to ignore physical placement when annotating and curating data. However, the current UKCN software implements only \"single-server mode\". Interfaces The UKCN allows users to access it in three ways: 1. When building applications, via the Knowledge Client 2. When curating and sharing data, via the HTML Browser interface 3. When uploading novel data artifacts programmatically, via the REST API This last interface is primarily useful when integrating the UKCN with existing data pipelines. Getting Started Go here to install and run the UKCN system.","title":"Sharing Service"},{"location":"sharingservice/#the-univeral-knowledge-collaboration-network","text":"The UKCN is a knowledge graph that is similar to other Wikidata-style knowledge graphs. Like existing systems, it: - Hosts data - Contains entities and properties - Offers a range of query interfaces, such as SPARQL and the Knowledge Client - Hosts both well-known objects (e.g., Barack Obama) and obscure ones (e.g., a random uploaded image file) - Largely relies on social processes for data curation Unlike existing systems, the UKCN also models the computational world, with support for storing files, databases, schemas, execution events, functions, and other items. This allows the UKCN to apply the virtues of traditional knowledge graph systems --- topic flexibility and efficient curation --- to all the data that an application developer might need.","title":"The Univeral Knowledge Collaboration Network"},{"location":"sharingservice/#using-the-ukcn","text":"Like Wikidata, the UKCN presents an HTML browser interface for users. Anyone can search and retrieve data from the UKCN . With an account, a user can create new UKCN objects, annotate and edit existing ones, run functions, and carry out a range of other tasks. Every data object in the UKCN has its own URL. This URL can be used in the browser to find an object. The same URL can be provided to the Knowledge Client for various use cases. Sharing data with a colleague is as easy as sharing a webpage: just send your friend the appropriate URL. Every data object in the UKCN has an affiliated user account as its owner. In the current version of the UKCN , all data objects are world-readable and world-writable. Future versions will implement user permissions that prevent unauthorized access and edits.","title":"Using the UKCN"},{"location":"sharingservice/#data-model","text":"Data objects in UKCN are immutable: with one important exception, they can never change and are never deleted. Every immutable data object has an obscure identifier . This can be used to fetch the data object, forever. Because obscure identifers are never recycled, and because data objects can never be modified, UKCN can be used for long-term provenance tracking. An object with an obscure identifier is akin to a particular version of a particular entity in Wikidata; it might be useful and popular, but probably not. The UKCN also offers well-known identifiers . This is the only kind of value in the UKCN that can change over time. A well-known identifier starts with the letter 'X', followed by an integer. It is akin to the set of top-level entities in Wikidata, such as Q76 (Barack Obama). A well-known identifier always points to a single immutable data object (which, of course, also has an obscure identifier). This is similar to the way in which a high-level Wikidata identifier (e.g, Q76) at any moment in time points to a particular version of the entity. In practice, users can mostly ignore this distinction. Most people will mostly deal with well-known objects; that is, objects currently pointed-to by a well-known identifier . Non-well-known objects are generally only of interest when looking at past versions (e.g., for provenance tracking reasons). Users retrieving UKCN objects using a single query interface, whether its via an obscure identifier or a well-known identifier,","title":"Data Model"},{"location":"sharingservice/#deployment","text":"There is a single UKCN that is implemented across multiple servers, in the same way there is a single World Wide Web implemented across multiple web servers. This will allow users and institutions to host data that might be tied to a particular location, while allowing users to ignore physical placement when annotating and curating data. However, the current UKCN software implements only \"single-server mode\".","title":"Deployment"},{"location":"sharingservice/#interfaces","text":"The UKCN allows users to access it in three ways: 1. When building applications, via the Knowledge Client 2. When curating and sharing data, via the HTML Browser interface 3. When uploading novel data artifacts programmatically, via the REST API This last interface is primarily useful when integrating the UKCN with existing data pipelines.","title":"Interfaces"},{"location":"sharingservice/#getting-started","text":"Go here to install and run the UKCN system.","title":"Getting Started"},{"location":"tutorial/","text":"Tutorial and Walkthrough We will walk through an example of adding data to the UKCN and then using it in the Knowledge Client . You should have already installed the software. If not, go follow the installation instructions . Jiayun, Yitong, Yuning, can we add the programmatic COVID example here? It should be the written-out version of the tutorial video. We demonstrate a real-life scenario where three users are collaborating to process the COVID-19 data during two weeks. Alice has some raw data that wants to share with others. Betty wants to do a predictive model with a trackable data source that is easy for debugging data and share the results. Charlie wants to analyze Besi\u2019s work and generate pictures for government reports. On Monday, week one , the first user, Alice, works at a data collection agency. Alice fetched data from covidtracking.com. Then Alice processed the data to only get the latest 20 day's COVID-19 cumulative positive cases for all states in the US. After processing, Alice published the result as a knpsValue and gave it a label. knps.publish_new(result,val_comment,\"LatestCovidData\",\"Alice\") The parameters are - data that the user wants to publish - a required comment - a label for this knpsValue - the name of user. On Wednesday, week one , the second user, Betty, who works at a university received the knpsValue from Alice via an email. Betty first loaded the variable with the ID given by Alice. Next, Betty extended the data from Alice with a regression model, yielding a prediction for the next day\u2019s case number for each state in the US. After processing data locally, Betty published the result as a knpsValue, and gave it a label. VAR_LABEL_GIVEN_BY_ALICE = \"LatestCovidData\" data_source = knps.get_label_content(VAR_LABEL_GIVEN_BY_ALICE) knps.publish_new(rst, val_comment, \"CovidPrediction\", \"Betty\", [VAR_LABEL_GIVEN_BY_ALICE, ]) The first four parameters are the same. The last parameter is the label of the knpsValue that the current knpsvalue depending on. On Friday, week one , Charlie, a government policymaker, was searching for a reliable data source on the internet. Charlie went to the main page of the KNPS, and got the label of the knpsValue generated by Betty. With the prediction results from Besi's research, Charlie was able to generate a visualization of the prediction. By transferring the graph to a knps.File type, Charlie published a knpsValue in the same way as mentioned before and gave it the label \"PredictionPic\". Charlie also sorted the predictions and got ten states with least predicted cases. Charlie published this with knpsValue and gave it the label \"TenStatesWithFewestCovid\" LABEL_FROM_BETTY = \"CovidPrediction\" total_val = knps.get_label_content(LABEL_FROM_BETTY) pre1 = knps.File(\"predict_1.png\") knps.publish_new(pre1, \"Predict image for week one\", \"CovidPredictionPic\", \"Charlie\", [LABEL_FROM_BETTY, ]) knps.publish_new(least_list, \"Ten states with the fewest COVID cases\", \"TenStatesWithFewestCovid\", \"Charlie\", [LABEL_FROM_BETTY, ]) In the first week, data flew from covidtraking.com to Alice, then to Betty, and finally to Charlie. Users can go to the main page of KNPS and see the newly published knpsValues. They can hover over to see a brief description or double click for a detailed page. [[/docs/files/front_2.png|align=center]] Blue squares mean different users. Rounded rectangles mean the immutable knpsValues. KnpsValues' automatically generated identifiers are shown in the black square and their comments are shown below the identifiers. Black squares represent the current content of a label. Arrows point from data sources to dependent data. On Monday, week two . The first user Alice fetched the data from covidtracking.com again, and updated the knpsvalue of the label \"LatestCovidData\". knps.publish_update(rst, comment, \"LatestCovidData\", \"Alice\") On Wednesday, week two . The second user Betty also updated the knpsValue of the label \"CovidPrediction\" based on the updated knpsValue from Alice. The first four parameters are the same, and the last parameter is the label of the knpsValue that the current knpsvalue depending on. PREV_LABEL = \"CovidPrediction\" VAR_ID_GIVEN_BY_ALICE = \"LatestCovidData\" data_source = knps.get_label_content(VAR_ID_GIVEN_BY_ALICE) knps.publish_update(rst, val_comment, PREV_LABEL, \"Betty\", [VAR_ID_GIVEN_BY_ALICE, ]) On Friday, week two . The third user Charlie updated the knpsvalue of the label \"PredictionPic\" and \"TenStatesWithFewestCovid\". LABEL_FROM_BETTY = \"CovidPrediction\" PREV_PIC = \"CovidPredictionPic\" PREV_VID = \"TenStatesWithFewestCovid\" total_val = knps.get_label_content(LABEL_FROM_BETTY) knps.publish_update(pre1, \"Second week prediction image\", PREV_PIC, \"Charlie\", [LABEL_FROM_BETTY,]) knps.publish_update(least_list, \"Ten states with the \\ fewest COVID cases\", PREV_VID, \"Charlie\", [LABEL_FROM_BETTY, ]) The overall dataflow is from covidtracking.com to Alice, then to Betty, and finally to Charlie. [[/docs/files/flow.png|align=center]]","title":"Tutorial"},{"location":"tutorial/#tutorial-and-walkthrough","text":"We will walk through an example of adding data to the UKCN and then using it in the Knowledge Client . You should have already installed the software. If not, go follow the installation instructions . Jiayun, Yitong, Yuning, can we add the programmatic COVID example here? It should be the written-out version of the tutorial video. We demonstrate a real-life scenario where three users are collaborating to process the COVID-19 data during two weeks. Alice has some raw data that wants to share with others. Betty wants to do a predictive model with a trackable data source that is easy for debugging data and share the results. Charlie wants to analyze Besi\u2019s work and generate pictures for government reports. On Monday, week one , the first user, Alice, works at a data collection agency. Alice fetched data from covidtracking.com. Then Alice processed the data to only get the latest 20 day's COVID-19 cumulative positive cases for all states in the US. After processing, Alice published the result as a knpsValue and gave it a label. knps.publish_new(result,val_comment,\"LatestCovidData\",\"Alice\") The parameters are - data that the user wants to publish - a required comment - a label for this knpsValue - the name of user. On Wednesday, week one , the second user, Betty, who works at a university received the knpsValue from Alice via an email. Betty first loaded the variable with the ID given by Alice. Next, Betty extended the data from Alice with a regression model, yielding a prediction for the next day\u2019s case number for each state in the US. After processing data locally, Betty published the result as a knpsValue, and gave it a label. VAR_LABEL_GIVEN_BY_ALICE = \"LatestCovidData\" data_source = knps.get_label_content(VAR_LABEL_GIVEN_BY_ALICE) knps.publish_new(rst, val_comment, \"CovidPrediction\", \"Betty\", [VAR_LABEL_GIVEN_BY_ALICE, ]) The first four parameters are the same. The last parameter is the label of the knpsValue that the current knpsvalue depending on. On Friday, week one , Charlie, a government policymaker, was searching for a reliable data source on the internet. Charlie went to the main page of the KNPS, and got the label of the knpsValue generated by Betty. With the prediction results from Besi's research, Charlie was able to generate a visualization of the prediction. By transferring the graph to a knps.File type, Charlie published a knpsValue in the same way as mentioned before and gave it the label \"PredictionPic\". Charlie also sorted the predictions and got ten states with least predicted cases. Charlie published this with knpsValue and gave it the label \"TenStatesWithFewestCovid\" LABEL_FROM_BETTY = \"CovidPrediction\" total_val = knps.get_label_content(LABEL_FROM_BETTY) pre1 = knps.File(\"predict_1.png\") knps.publish_new(pre1, \"Predict image for week one\", \"CovidPredictionPic\", \"Charlie\", [LABEL_FROM_BETTY, ]) knps.publish_new(least_list, \"Ten states with the fewest COVID cases\", \"TenStatesWithFewestCovid\", \"Charlie\", [LABEL_FROM_BETTY, ]) In the first week, data flew from covidtraking.com to Alice, then to Betty, and finally to Charlie. Users can go to the main page of KNPS and see the newly published knpsValues. They can hover over to see a brief description or double click for a detailed page. [[/docs/files/front_2.png|align=center]] Blue squares mean different users. Rounded rectangles mean the immutable knpsValues. KnpsValues' automatically generated identifiers are shown in the black square and their comments are shown below the identifiers. Black squares represent the current content of a label. Arrows point from data sources to dependent data. On Monday, week two . The first user Alice fetched the data from covidtracking.com again, and updated the knpsvalue of the label \"LatestCovidData\". knps.publish_update(rst, comment, \"LatestCovidData\", \"Alice\") On Wednesday, week two . The second user Betty also updated the knpsValue of the label \"CovidPrediction\" based on the updated knpsValue from Alice. The first four parameters are the same, and the last parameter is the label of the knpsValue that the current knpsvalue depending on. PREV_LABEL = \"CovidPrediction\" VAR_ID_GIVEN_BY_ALICE = \"LatestCovidData\" data_source = knps.get_label_content(VAR_ID_GIVEN_BY_ALICE) knps.publish_update(rst, val_comment, PREV_LABEL, \"Betty\", [VAR_ID_GIVEN_BY_ALICE, ]) On Friday, week two . The third user Charlie updated the knpsvalue of the label \"PredictionPic\" and \"TenStatesWithFewestCovid\". LABEL_FROM_BETTY = \"CovidPrediction\" PREV_PIC = \"CovidPredictionPic\" PREV_VID = \"TenStatesWithFewestCovid\" total_val = knps.get_label_content(LABEL_FROM_BETTY) knps.publish_update(pre1, \"Second week prediction image\", PREV_PIC, \"Charlie\", [LABEL_FROM_BETTY,]) knps.publish_update(least_list, \"Ten states with the \\ fewest COVID cases\", PREV_VID, \"Charlie\", [LABEL_FROM_BETTY, ]) The overall dataflow is from covidtracking.com to Alice, then to Betty, and finally to Charlie. [[/docs/files/flow.png|align=center]]","title":"Tutorial and Walkthrough"}]}