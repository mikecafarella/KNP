#
# Comparing GDP
#
def CompareGDP(gdp1: GDP, gdp2: GDP) -> __Image__:
    assert(gdp1.currency == gdp2.currency)
    assert(gdp1.is-inflation-adjusted == gdp2.is-inflation-adjusted)
    return PlotTimeSeries(gdp1, gdp2, "GDP")

def PlotTimeSeries(ts1: TimeSeries, ts2: TimeSeries, title: __String__) -> __Image__:
    return PlotTwoLines(ts1.x, ts1.y, ts1.name, ts2.x, ts2.y, ts2.name, title)

def PlotTwoLines(x1: __List__, y1: __List__, name1: __String__, x2: __List__, y2: __List__, name2:__String__, title: __String__) -> __Image__:
    return __InvokeExternal__(kgpsupport.plot, (x1, y1, name1, x2, y2, name2, title))


#
# Design Decision
#
# What if someone invokes CompareGDP(USA, Canada)?
#
# The system could:
# -- Complain that it's not possible (even though it makes some human sense)
# -- Do automatic type coercion to invoke CompareGDP(USA.gdp, Canada.gdp) as above
# -- Require additional code like below
#
def CompareGDP(region1: PoliticalGeography, region2: PoliticalGeography) -> __Image__:
    CompareGDP(region1.gdp, region2.gdp)


#
# Comparing people
#
def ComparePeople(p1: Person, p2: Person) -> __Table__:
    return GenerateTable(p1, p2)

def ComparePoliticians(p1: Politician, p2: Politician) -> __Table__:
    return GenerateTable(p1, p2, properties=[image, home-state])

def CompareMovieStars(p1: MovieStar, p2: MovieStar) -> __Table__:
    return GenerateTable(p1, p2, properties=[image, box-office])

def GenerateTable(e1: __Entity__, e2: __Entity__, propertyList=[]) -> __Table__:
    allProperties = e1.__properties__.intersect(e2.__properties__)
    while len(propertyList) < 3:
        propertyList.add(allProperties.pop())

    return __Table__(propertyList, e1, e2)


#
# Some points:
#
# 1) I wish the "domain knowledge" were somehow more separate from the "code
# knowledge", as I expect them to involve different audiences
#
# 2) All types and accessors are synthesized by the Ideal KG process
#


#
# Example way to implement type polymorphism
#
def ShowComponents(ce: CompositeEntity) -> __ExplodedExplorer__;

def ShowComponents(p: Polity) -> __ExplodedExplorer__:
    return ShowMapPartInteractive(p, p.parts)

def ShowComponents(s: Sum) -> __ExplodedExplorer__:
    return ShowArithmeticPartInteractive(s, s.parts)

def ShowComponents(m: Machine) -> __ExplodedExplorer__:
    return ShowMechanicalParts(m, m.parts)

def ShowComponents(o: Organization) -> __ExplodedExplorer__:
    return ShowOrganizationalParts(o, p.parts)

def ShowComponents(ip: IndustrialProcess) -> __ExplodedExplorer__:
    return ShowProcessSteps(ip, ip.parts)

